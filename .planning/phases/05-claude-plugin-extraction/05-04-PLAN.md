---
phase: 05-claude-plugin-extraction
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - dotconfigs
  - plugins/claude/project.sh
autonomous: true

must_haves:
  truths:
    - "dotconfigs project . scaffolds project with .claude/settings.json, CLAUDE.md, .git/info/exclude"
    - "dotconfigs project . is a top-level command, not a plugin-specific action"
    - "dotconfigs project claude . runs just the Claude plugin's project setup"
    - "Project setup is interactive with a short project-specific wizard"
    - "Project settings stored in .dotconfigs.json (JSON, parsed with jq)"
  artifacts:
    - path: "dotconfigs"
      provides: "Updated CLI with project command routing"
      contains: "cmd_project"
    - path: "plugins/claude/project.sh"
      provides: "Claude plugin project scaffolding"
      exports: ["plugin_claude_project"]
  key_links:
    - from: "dotconfigs"
      to: "plugins/claude/project.sh"
      via: "source + plugin_claude_project call"
      pattern: "plugin_claude_project"
    - from: "plugins/claude/project.sh"
      to: ".dotconfigs.json"
      via: "jq writes project config"
      pattern: "jq.*dotconfigs"
---

<objective>
Add the `project` command to the dotconfigs CLI and implement plugins/claude/project.sh, extracting from deploy.sh cmd_project(). Project becomes a top-level command that delegates to plugins.

Purpose: CLPL-04 (project scaffolding preserved), plus user decisions on project command being top-level with plugin hooks and .dotconfigs.json config format.

Output: Working `dotconfigs project .` and `dotconfigs project claude .` commands.
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-claude-plugin-extraction/05-CONTEXT.md
@.planning/phases/05-claude-plugin-extraction/05-RESEARCH.md
@.planning/phases/05-claude-plugin-extraction/05-02-SUMMARY.md
@.planning/phases/05-claude-plugin-extraction/05-03-SUMMARY.md
@deploy.sh
@dotconfigs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project command to dotconfigs CLI</name>
  <files>dotconfigs</files>
  <action>
    Add a `project` subcommand to the dotconfigs CLI entry point. Per user decision, project is a **top-level command** where each plugin hooks in with its own project-level setup.

    **Routing logic:**

    ```
    dotconfigs project .              # Run all plugins' project setup
    dotconfigs project claude .       # Run just Claude plugin's project setup
    dotconfigs project git .          # Run just Git plugin's project setup (Phase 6)
    ```

    Add `cmd_project()` function:

    1. Parse args: First arg could be a plugin name or a path.
       - If first arg matches an available plugin (plugin_exists check), treat it as plugin filter, second arg is path
       - Otherwise, first arg is path, run all plugins

    2. Resolve path to absolute (handle relative paths and `.`)

    3. Validate git repo (`validate_git_repo`)

    4. If plugin filter specified:
       - Source `$PLUGINS_DIR/$plugin/project.sh`
       - Call `plugin_${plugin}_project "$project_path"`

    5. If no filter (run all plugins):
       - Discover plugins, for each that has a `project.sh` file:
         - Source `$PLUGINS_DIR/$plugin/project.sh`
         - Call `plugin_${plugin}_project "$project_path"`

    Add to the `main()` case statement:
    ```
    project)
        cmd_project "${@:2}"
        ;;
    ```

    Update `show_usage()` to include the project command:
    ```
    dotconfigs project [plugin] <path>  Scaffold project configuration
    ```

    Update examples:
    ```
    dotconfigs project .              Run all plugin project setup
    dotconfigs project claude .       Run Claude project setup only
    ```
  </action>
  <verify>
    - `bash -n dotconfigs` returns 0
    - `grep 'cmd_project' dotconfigs` finds the function
    - `grep 'project)' dotconfigs` finds the case branch
    - `grep 'project.*plugin.*path' dotconfigs` finds usage text
  </verify>
  <done>dotconfigs CLI routes project command to plugin project.sh files, supports both all-plugins and single-plugin modes</done>
</task>

<task type="auto">
  <name>Task 2: Create plugins/claude/project.sh</name>
  <files>plugins/claude/project.sh</files>
  <action>
    Create plugins/claude/project.sh with `plugin_claude_project()` extracted from deploy.sh cmd_project() (lines 774-1053). This is the Claude plugin's contribution to project scaffolding.

    **Structure:**

    ```
    # plugins/claude/project.sh — Claude Code project scaffolding
    # Sourced by dotconfigs entry point. Do not execute directly.

    # Internal: Detect project type from filesystem
    _claude_detect_project_type() { ... }

    # Internal: Merge JSON settings files
    _claude_merge_settings_json() { ... }

    # Main entry point — called by dotconfigs project command
    plugin_claude_project() { ... }
    ```

    **Key changes from deploy.sh cmd_project():**

    1. **Interactive by default** — Per user decision, project setup is always interactive. Drop the `--interactive` flag parsing. The function receives just `$project_path`.

    2. **Asset paths** — Templates reference `$PLUGIN_DIR/templates/`:
       - `$PLUGIN_DIR/templates/settings/base.json`
       - `$PLUGIN_DIR/templates/settings/${project_type}.json`
       - `$PLUGIN_DIR/templates/hooks-conf/${profile}.conf`

    3. **Project config in .dotconfigs.json** — Per user decision, project settings stored in `.dotconfigs.json` (JSON, parsed with jq), not loose files. After scaffolding, write project config:

       ```json
       {
         "version": "2.0",
         "plugins": {
           "claude": {
             "project_type": "python",
             "settings_profile": "base",
             "hooks_profile": "default"
           }
         }
       }
       ```

       Use jq to create/update the file. If .dotconfigs.json already exists, merge into it (don't overwrite other plugins' config). If jq not available, fall back to creating a simple JSON string with printf.

    4. **Commit or exclude choice** — Per user decision, at the end ask user whether to commit .dotconfigs.json or add to .git/info/exclude. Use wizard_yesno.

    5. **Scaffolding steps** (adapted from cmd_project):

       a. Print header with project name
       b. Detect project state (greenfield vs brownfield — check for existing .claude/, CLAUDE.md)
       c. Detect project type (_claude_detect_project_type — same logic as deploy.sh detect_project_type)
       d. Step 1: Build and deploy settings.json — merge base + type overlay into .claude/settings.json. If exists, ask overwrite/skip.
       e. Step 2: Deploy hooks.conf — select profile (default/strict/permissive), copy to .claude/hooks.conf. Adjust defaults by project type (disable ruff for node). Platform-aware sed for in-place edit (macOS vs Linux).
       f. Step 3: Create/update CLAUDE.md — minimal project CLAUDE.md. If exists, offer to append section or skip.
       g. Step 4: Git exclusions — add CLAUDE.md, .claude/, .claude-project to .git/info/exclude
       h. Step 5: Save to .dotconfigs.json — write project config via jq
       i. Step 6: Ask commit or exclude .dotconfigs.json

    6. **_claude_detect_project_type()** — Extract from deploy.sh detect_project_type() (lines 702-729). Same logic: check for pyproject.toml, package.json, go.mod, default to "generic".

    7. **_claude_merge_settings_json()** — Extract from deploy.sh merge_settings_json() (lines 731-772). Same logic: jq deep merge with python fallback.

    **Bash 3.2 compatibility:** Same constraints. Note: jq is a runtime dependency for .dotconfigs.json. If not available, provide a fallback that creates the JSON with printf/echo (acceptable since the JSON structure is simple).
  </action>
  <verify>
    - `bash -n plugins/claude/project.sh` returns 0
    - `grep 'plugin_claude_project' plugins/claude/project.sh` finds the main function
    - `grep '_claude_detect_project_type' plugins/claude/project.sh` finds project type detection
    - `grep '_claude_merge_settings_json' plugins/claude/project.sh` finds JSON merge
    - `grep 'dotconfigs.json' plugins/claude/project.sh` finds project config handling
    - `grep 'wizard_yesno' plugins/claude/project.sh` finds interactive prompts
    - No bash 4+ syntax: `grep -E 'local -n|declare -A|\$\{[^}]+,,\}' plugins/claude/project.sh` returns nothing
  </verify>
  <done>
    - plugin_claude_project() scaffolds Claude config for a project
    - Interactive wizard for settings profile, hooks profile, CLAUDE.md
    - Project type auto-detected
    - Config saved to .dotconfigs.json (jq with printf fallback)
    - User chooses commit or exclude for .dotconfigs.json
    - Bash 3.2 compatible
  </done>
</task>

</tasks>

<verification>
- `dotconfigs project` shows usage (no path given)
- `dotconfigs project claude .` would invoke plugin_claude_project (can Ctrl+C to verify routing)
- `bash -n dotconfigs && bash -n plugins/claude/project.sh` both pass
</verification>

<success_criteria>
- dotconfigs CLI has working project command with plugin routing
- plugins/claude/project.sh provides full project scaffolding
- .dotconfigs.json used for project config storage
- All code bash 3.2 compatible
</success_criteria>

<output>
After completion, create `.planning/phases/05-claude-plugin-extraction/05-04-SUMMARY.md`
</output>
