---
phase: 11-json-config-core-deploy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/deploy.sh
autonomous: true

must_haves:
  truths:
    - "jq dependency is checked at deploy time with clear install instructions"
    - "JSON config is parsed recursively to find all source+target module pairs"
    - "Tilde-expanded target paths resolve correctly to absolute paths"
    - "Directory sources deploy each file individually (not directory symlinks)"
    - "Include filter restricts which files are deployed from a directory source"
    - "Symlink, copy, and append methods all work correctly"
    - "Dry-run mode previews operations without writing to disk"
    - "Force mode overwrites conflicts without prompting"
    - "Deploy reports per-module status: created, updated, unchanged, skipped"
  artifacts:
    - path: "lib/deploy.sh"
      provides: "Generic JSON-driven deployment engine"
      contains: "deploy_from_json"
  key_links:
    - from: "lib/deploy.sh"
      to: "lib/symlinks.sh"
      via: "backup_and_link function call"
      pattern: "backup_and_link"
---

<objective>
Build the generic JSON-driven deployment engine that reads a config file and creates symlinks/copies for all modules.

Purpose: This is the foundation for all deployment in v3.0. The deployer is plugin-agnostic -- it knows nothing about "claude" or "git", only source/target/method/include.

Output: `lib/deploy.sh` -- a library sourced by the CLI entry point, providing `deploy_from_json()` as the main entry point.
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-json-config-core-deploy/11-RESEARCH.md
@lib/symlinks.sh
@global.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/deploy.sh with generic JSON deployer</name>
  <files>lib/deploy.sh</files>
  <action>
Create `lib/deploy.sh` -- a shared library sourced by the CLI entry point. Must be bash 3.2 compatible (no namerefs, no associative arrays).

**Functions to implement:**

1. `check_jq()` -- Check jq is installed. On failure, print install instructions for macOS (brew), Ubuntu (apt), Fedora (dnf) and return 1.

2. `expand_tilde()` -- Takes a path string, replaces leading `~` with `$HOME`. Use pattern: `echo "${1/#\~/$HOME}"`.

3. `parse_modules()` -- Takes config_file path. Uses jq to recursively find all objects with `source` and `target` fields. Outputs tab-separated lines: `source\ttarget\tmethod\tinclude_csv`. Use jq's `..` recursive descent, `select(type == "object")`, `select(has("source") and has("target"))`. For include, use `(.include // [] | join(","))`. Use `@tsv` for output.

4. `parse_modules_in_group()` -- Takes config_file and group_key. If group_key is empty, calls `parse_modules`. Otherwise uses jq to filter to `.[$group]` first, then same recursive descent.

5. `deploy_module()` -- Takes source, target, method, include_csv, dotconfigs_root, dry_run (true/false), interactive_mode (true/false/force). Steps:
   - Expand tilde in target via `expand_tilde`
   - Make source absolute: if not starting with `/`, prepend `$dotconfigs_root/`
   - Validate source exists (warn and skip if not)
   - Switch on method:
     - **symlink**: If source is a directory, call `deploy_directory_files`. If source is a file, call `backup_and_link` from lib/symlinks.sh (for live deploy) or print "Would link" (for dry-run). When calling `backup_and_link`, pass `$(basename "$target")` as the 3rd "name" parameter (display name for conflict prompts).
     - **copy**: If dry-run, print "Would copy". Otherwise `mkdir -p` parent, `cp -p` source to target. If target already matches source content, report "Unchanged".
     - **append**: If dry-run, print "Would append". Otherwise `mkdir -p` parent, check if content already present (idempotent), `cat >> target` if not.
   - Return status string via stdout: "created", "updated", "unchanged", or "skipped".

6. `deploy_directory_files()` -- Takes source_dir, target_dir, include_csv, dotconfigs_root, dry_run, interactive_mode. Steps:
   - mkdir -p target_dir (unless dry-run)
   - If include_csv is non-empty, split on comma into array, deploy only those files
   - If include_csv is empty, deploy all files in source_dir
   - For each file, call `backup_and_link` passing `$(basename "$file")` as the name parameter (or dry-run equivalent)
   - Track and return counts

7. `deploy_from_json()` -- Main entry point. Takes config_file, dotconfigs_root, and optional group_key, dry_run, force flags. Steps:
   - Call `check_jq` (bail on failure)
   - Validate config_file exists
   - Parse modules (all or filtered by group)
   - Set interactive_mode based on force flag
   - Loop over parsed modules, call `deploy_module` for each
   - Track counters: created, updated, unchanged, skipped
   - Print summary banner with counts

**Status reporting format:**
- Use `  ` prefix (2 spaces) for per-file lines
- Symbols: checkmark for created/updated, dash for skipped, "Unchanged:" for unchanged
- Dry-run lines use "Would link/Would copy/Would append" prefix
- Show relative source path and absolute target path: `plugins/claude/hooks/block-destructive.sh -> ~/.claude/hooks/block-destructive.sh`

**Key constraints:**
- No `local -n` or `declare -n` (bash 3.2)
- Use `eval` pattern for counter increment: `eval "$_var=\$(( \$$_var + 1 ))"`
- All jq calls use `-r` for raw output
- Handle jq errors gracefully (empty config = no modules, not a crash)
- Reuse `backup_and_link()` and `is_dotconfigs_owned()` from lib/symlinks.sh (already sourced by entry point)
  </action>
  <verify>
Run: `bash -n lib/deploy.sh` (syntax check passes)
Run: `grep -c 'local -n\|declare -n' lib/deploy.sh` returns 0 (no namerefs)
Run: `grep -c 'deploy_from_json\|deploy_module\|parse_modules\|check_jq\|expand_tilde' lib/deploy.sh` returns at least 5 (all functions present)
  </verify>
  <done>
lib/deploy.sh exists with all 7 functions. Syntax-valid bash 3.2. No namerefs. Reuses backup_and_link from lib/symlinks.sh.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify deploy engine with global.json parsing</name>
  <files>lib/deploy.sh</files>
  <action>
Verify the deploy engine works by testing jq queries against the actual global.json file.

Run these verification commands and fix any issues:

1. `jq -r '.. | select(type == "object") | select(has("source") and has("target")) | [.source, .target, .method, (.include // [] | join(","))] | @tsv' global.json`
   - Should output ~10 lines (one per module in global.json)
   - Each line should have 4 tab-separated fields

2. `jq -r --arg group "claude" '.[$group] | .. | select(type == "object") | select(has("source") and has("target")) | [.source, .target, .method, (.include // [] | join(","))] | @tsv' global.json`
   - Should output only claude modules (~4 lines)

3. `jq -r --arg group "git" '.[$group] | .. | select(type == "object") | select(has("source") and has("target")) | [.source, .target, .method, (.include // [] | join(","))] | @tsv' global.json`
   - Should output only git modules (~3 lines)

4. Source lib/deploy.sh and lib/symlinks.sh, then call `expand_tilde "~/.claude/hooks"` and verify it outputs the full path.

5. Source lib/deploy.sh, then call `parse_modules global.json` and verify output has correct format.

Fix any issues found during verification. Ensure paths with spaces (like VS Code's `~/Library/Application Support/...`) are handled correctly in the jq output and bash parsing.
  </action>
  <verify>
The jq queries produce correct tab-separated output for global.json.
`parse_modules global.json` returns all modules with correct fields.
`parse_modules_in_group global.json claude` returns only claude modules.
Paths with spaces are preserved correctly.
  </verify>
  <done>
Deploy engine correctly parses global.json. Group filtering works. Paths with spaces handled. All modules discovered recursively.
  </done>
</task>

</tasks>

<verification>
1. `bash -n lib/deploy.sh` -- no syntax errors
2. `grep -c 'local -n\|declare -n' lib/deploy.sh` returns 0
3. jq query against global.json returns all expected modules
4. Group filtering returns subset correctly
5. `expand_tilde` converts tilde paths to absolute paths
</verification>

<success_criteria>
- lib/deploy.sh exists and is syntactically valid bash
- All 7 functions are implemented: check_jq, expand_tilde, parse_modules, parse_modules_in_group, deploy_module, deploy_directory_files, deploy_from_json
- No bash 4+ features used (namerefs, associative arrays)
- jq queries correctly discover all modules in global.json
- Reuses existing backup_and_link from lib/symlinks.sh
</success_criteria>

<output>
After completion, create `.planning/phases/11-json-config-core-deploy/11-01-SUMMARY.md`
</output>
