---
phase: 07-integration-and-polish
plan: 05
type: execute
wave: 4
depends_on: ["07-03"]
files_modified:
  - dotconfigs
autonomous: true

must_haves:
  truths:
    - "dotconfigs deploy creates a symlink on PATH so the CLI is callable from any directory"
    - "dotconfigs project with no path argument detects CWD as the target project repo and confirms with y/n"
    - "dotconfigs project from the dotconfigs repo itself still requires an explicit path argument"
    - "Symlink is idempotent — running deploy twice doesn't error or duplicate"
  artifacts:
    - path: "dotconfigs"
      provides: "PATH symlink creation during deploy and smart project path detection"
      contains: "_create_path_symlink"
  key_links:
    - from: "dotconfigs:cmd_deploy"
      to: "dotconfigs:_create_path_symlink"
      via: "called after all plugin deploys complete"
      pattern: "_create_path_symlink"
    - from: "dotconfigs:cmd_project"
      to: "dotconfigs:_detect_project_path"
      via: "called when no path argument provided"
      pattern: "_detect_project_path"
---

<objective>
Add PATH symlink creation during deploy and smart project path detection for CLI usability.

Purpose: CLI-07 — makes dotconfigs callable from any directory. Smart project detection lets users run `dotconfigs project` from within a target repo without specifying the path explicitly.
Output: Updated dotconfigs entry point with PATH symlink logic and smart project path resolution.
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-integration-and-polish/07-CONTEXT.md
@.planning/phases/07-integration-and-polish/07-03-SUMMARY.md

@dotconfigs
@lib/symlinks.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PATH symlink creation to deploy flow</name>
  <files>dotconfigs</files>
  <action>
    **Add `_create_path_symlink()` helper function in dotconfigs:**

    Logic:
    1. Determine symlink target: try `$HOME/.local/bin/dotconfigs` first. If `$HOME/.local/bin` doesn't exist, fall back to `/usr/local/bin/dotconfigs`.
    2. Target selection rationale: `~/.local/bin` doesn't require sudo and is on PATH for most modern Linux/macOS setups. `/usr/local/bin` is the traditional fallback.
    3. Check if symlink already exists and points to `$SCRIPT_DIR/dotconfigs`:
       - If yes: print "dotconfigs already on PATH" and return (idempotent)
       - If exists but points elsewhere: warn about existing symlink, ask to overwrite
       - If a regular file exists at target: warn and skip (don't overwrite unknown files)
    4. Create parent directory if needed: `mkdir -p "$(dirname "$target")"`
    5. Create symlink: `ln -sf "$SCRIPT_DIR/dotconfigs" "$target"`
    6. Verify: check `command -v dotconfigs` works. If not, warn that the target dir may not be on PATH and suggest adding it.
    7. Respect --dry-run: if dry_run flag is set, print "Would create symlink: $target -> $SCRIPT_DIR/dotconfigs" and return
    8. Respect --force: if force flag, skip overwrite confirmation

    **Integrate into deploy flow:**

    Call `_create_path_symlink` at the END of `cmd_deploy()` (after all plugin deploys), passing through the dry_run and force flags. This runs whether deploying a single plugin or all plugins — because PATH availability is a CLI-level concern, not plugin-specific.

    Print a section header: "CLI availability:" before the symlink output, consistent with plugin deploy section headers.

    **Edge cases:**
    - If neither `~/.local/bin` nor `/usr/local/bin` is writable: print warning with manual instructions (`export PATH="$SCRIPT_DIR:$PATH"` in shell profile) and continue (don't fail the deploy)
    - If symlink creation fails (permissions): catch error, print instructions, don't fail deploy
  </action>
  <verify>
    1. `bash -n dotconfigs` — no syntax errors
    2. Function `_create_path_symlink` exists in dotconfigs
    3. Grep for `_create_path_symlink` call within cmd_deploy
  </verify>
  <done>
    _create_path_symlink() exists and is called at end of cmd_deploy(). Creates symlink to ~/.local/bin/dotconfigs (or /usr/local/bin fallback). Idempotent — skips if already correct. Respects --dry-run and --force. Fails gracefully with manual instructions if permissions insufficient.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add smart project path detection to cmd_project</name>
  <files>dotconfigs</files>
  <action>
    **Update cmd_project() in dotconfigs to detect CWD as target project:**

    Current behaviour: `dotconfigs project [plugin] <path>` — path is always required.

    New behaviour:
    1. If no path argument AND no plugin filter: detect if CWD is a suitable project target
    2. If no path argument AND plugin filter provided but nothing after it: same detection

    **Detection logic — add `_detect_project_path()` helper:**

    1. Check if CWD is the dotconfigs repo itself:
       - Test: `[[ "$(pwd)" == "$SCRIPT_DIR" ]]` or more robustly, check if `$PWD/dotconfigs` is the entry point script AND `$PWD/plugins/` exists
       - If YES: this is the dotconfigs repo, path is required. Print error: "Cannot use dotconfigs repo as project target. Specify a path: dotconfigs project <path>"
       - Return 1
    2. Check if CWD is a git repo: `git -C "$PWD" rev-parse --git-dir >/dev/null 2>&1`
       - If NOT a git repo: print error, return 1
    3. CWD is a valid project repo. Confirm with user:
       - Print: "Detected project: $(basename "$PWD") ($PWD)"
       - `wizard_yesno "Use this directory?" "y"` — default yes
       - If confirmed: set project_path="$PWD", continue
       - If declined: print "Specify path: dotconfigs project <path>", return 1

    **Update cmd_project() argument parsing:**

    Current flow:
    ```
    # If first arg is a plugin name, treat it as filter
    if plugin_exists "$1"; then plugin_filter="$1"; shift; fi
    # Next arg should be the path
    if [[ $# -eq 0 ]]; then error "Path required"; fi
    ```

    New flow:
    ```
    # If first arg is a plugin name, treat it as filter
    if [[ $# -gt 0 ]] && plugin_exists "$1"; then plugin_filter="$1"; shift; fi
    # If no path argument, try CWD detection
    if [[ $# -eq 0 ]]; then
        project_path=$(_detect_project_path) || return 1
    else
        project_path="$1"; shift
    fi
    ```

    The _detect_project_path function prints the confirmation prompt and echoes the path to stdout if confirmed. Actually, cleaner: have it set a variable rather than echo, since the prompt output would mix with the path. Use a pattern like:
    ```
    _detect_project_path() {
        # ... detection logic, prints to stderr for prompts ...
        # Sets DETECTED_PROJECT_PATH global variable
        DETECTED_PROJECT_PATH="$PWD"
    }
    ```

    Or simpler: just inline the detection in cmd_project since it's only used there.
  </action>
  <verify>
    1. `bash -n dotconfigs` — no syntax errors
    2. From the dotconfigs repo: `./dotconfigs project` — errors with "Cannot use dotconfigs repo" message
    3. From another git repo: `dotconfigs project` (if on PATH) — detects CWD, prompts y/n
    4. Explicit path still works: `dotconfigs project /some/path` — unchanged behaviour
    5. Plugin filter still works: `dotconfigs project claude /some/path` — unchanged behaviour
    6. Plugin filter with CWD: `dotconfigs project claude` from a project repo — detects CWD, runs only Claude plugin
  </verify>
  <done>
    cmd_project() detects CWD as target when no path given. Rejects dotconfigs repo as target. Confirms detected path with y/n prompt. Explicit path and plugin filter modes unchanged.
  </done>
</task>

</tasks>

<verification>
1. `bash -n dotconfigs` — syntactically valid
2. Deploy creates PATH symlink (check with `ls -la ~/.local/bin/dotconfigs` or `/usr/local/bin/dotconfigs`)
3. Second deploy reports symlink already correct (idempotent)
4. `dotconfigs project` from a project repo prompts with detected path
5. `dotconfigs project` from the dotconfigs repo errors clearly
6. `dotconfigs project claude` from a project repo works with CWD detection
7. `dotconfigs project /explicit/path` still works unchanged
</verification>

<success_criteria>
- Deploy creates PATH symlink so dotconfigs is callable from any directory
- Symlink creation is idempotent and fails gracefully
- Project command detects CWD when no path given
- Dotconfigs repo rejected as project target
- All existing project command invocations unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/07-integration-and-polish/07-05-SUMMARY.md`
</output>
