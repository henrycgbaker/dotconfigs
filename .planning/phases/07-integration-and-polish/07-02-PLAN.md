---
phase: 07-integration-and-polish
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - dotconfigs
  - plugins/claude/deploy.sh
  - plugins/git/deploy.sh
autonomous: true

must_haves:
  truths:
    - "dotconfigs status shows all plugins with per-file state (deployed, drifted, not deployed)"
    - "dotconfigs status claude filters to Claude plugin only"
    - "dotconfigs list shows plugins with installed/not-installed using colour + symbols"
    - "Status output uses green for OK, yellow for drift, red for missing when TTY"
    - "Status output is plain text (no ANSI codes) when piped"
  artifacts:
    - path: "plugins/claude/deploy.sh"
      provides: "plugin_claude_status() function"
      contains: "plugin_claude_status"
    - path: "plugins/git/deploy.sh"
      provides: "plugin_git_status() function"
      contains: "plugin_git_status"
    - path: "dotconfigs"
      provides: "cmd_status() and rewritten cmd_list()"
      contains: "cmd_status"
  key_links:
    - from: "dotconfigs:cmd_status"
      to: "plugins/claude/deploy.sh:plugin_claude_status"
      via: "dynamic function call via plugin_${plugin}_status"
      pattern: "plugin_.*_status"
    - from: "plugins/claude/deploy.sh:plugin_claude_status"
      to: "lib/symlinks.sh:check_file_state"
      via: "function call per managed file"
      pattern: "check_file_state"
    - from: "dotconfigs:cmd_list"
      to: "lib/colours.sh:colour_green"
      via: "coloured plugin status output"
      pattern: "colour_green\\|colour_red"
---

<objective>
Implement status and list commands with per-file drift detection and coloured output.

Purpose: Gives users visibility into deployment state across all plugins (CLI-04, CLI-05). Status shows per-file granularity with drift detection. List shows minimal plugin inventory.
Output: Working `dotconfigs status [plugin]` and `dotconfigs list` commands
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-integration-and-polish/07-RESEARCH.md
@.planning/phases/07-integration-and-polish/07-01-SUMMARY.md

@lib/colours.sh
@lib/symlinks.sh
@lib/discovery.sh
@dotconfigs
@plugins/claude/deploy.sh
@plugins/git/deploy.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plugin_claude_status() and plugin_git_status() functions</name>
  <files>plugins/claude/deploy.sh, plugins/git/deploy.sh</files>
  <action>
    **Add plugin_claude_status() to plugins/claude/deploy.sh:**

    This function reports per-file deployment state for the Claude plugin. Add it after the existing `_claude_load_config()` function.

    Logic:
    1. Call `_claude_load_config`. If fails, print "claude" as "not configured" (red) and return.
    2. Build a list of expected files to check based on .env configuration:
       - If CLAUDE_SETTINGS_ENABLED=true: check `$CLAUDE_DEPLOY_TARGET/settings.json` against `$DOTCONFIGS_ROOT/settings.json`
       - CLAUDE.md: check `$CLAUDE_DEPLOY_TARGET/CLAUDE.md` (this is a generated file not a symlink, so it's always "deployed" if it exists, "not-deployed" if missing)
       - For each hook in CLAUDE_HOOKS_ENABLED_ARRAY: check `$CLAUDE_DEPLOY_TARGET/hooks/$hook` against `$PLUGIN_DIR/hooks/$hook`
       - For each skill in CLAUDE_SKILLS_ENABLED_ARRAY: check `$CLAUDE_DEPLOY_TARGET/commands/${skill}.md` against `$PLUGIN_DIR/commands/${skill}.md`
    3. For each file, call `check_file_state()` to get state. Count ok/drift/missing.
       - Special case: CLAUDE.md is a generated file (not symlink). Check: if file exists, "deployed"; if not, "not-deployed". Don't use check_file_state for it.
    4. Print plugin header line with overall status:
       - All OK: green "claude" + checkmark + "deployed"
       - Any drift: yellow "claude" + delta + "deployed (drift detected)"
       - Any missing: yellow "claude" + delta + "partially deployed"
    5. Print per-file detail lines using `_print_file_status()` from lib/colours.sh (indented under plugin header).

    **Add plugin_git_status() to plugins/git/deploy.sh:**

    Git plugin manages git config values (not symlinks), so status checking differs.

    Logic:
    1. Call `_git_load_config`. If fails, print "git" as "not configured" (red) and return.
    2. Check git config values against .env expectations:
       - Identity: compare `git config --global user.name` vs GIT_USER_NAME, `git config --global user.email` vs GIT_USER_EMAIL
       - Workflow: compare each GIT_* setting vs `git config --global` value
       - Aliases: check each enabled alias exists with correct value
       - Hooks: if global scope, check core.hooksPath and hook files exist; if project scope, just note "per-project (use dotconfigs project git)"
    3. For each config item: "deployed" if matches, "drifted" if different value, "not-deployed" if missing
    4. Print plugin header with overall status (same format as Claude)
    5. Print per-item detail:
       - `user.name` checkmark ok / delta drifted (current: X, expected: Y)
       - `user.email` checkmark ok
       - `pull.rebase` checkmark ok
       - etc.

    Use `_print_file_status()` for symlink-managed items and a new `_print_config_status()` helper (local to git/deploy.sh) for git config items. The _print_config_status helper takes display_name and state and prints in the same format.

    **User decision compliance:** Per-file granularity, three-state model, drift detection (report only, no fix commands), ANSI colour when TTY.
  </action>
  <verify>
    1. `bash -n plugins/claude/deploy.sh` — no syntax errors
    2. `bash -n plugins/git/deploy.sh` — no syntax errors
    3. Both files still have their existing deploy functions intact (plugin_claude_deploy, plugin_git_deploy)
  </verify>
  <done>
    plugins/claude/deploy.sh exports plugin_claude_status() showing per-file state for settings.json, CLAUDE.md, hooks, skills. plugins/git/deploy.sh exports plugin_git_status() showing per-config-item state for identity, workflow, aliases, hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cmd_status() and rewrite cmd_list() in dotconfigs</name>
  <files>dotconfigs</files>
  <action>
    **Replace the cmd_status() stub (from Plan 01) with real implementation:**

    1. `cmd_status()` accepts optional plugin filter as $1
    2. Call `init_colours`
    3. Check if .env exists. If not: "No configuration found. Run 'dotconfigs setup <plugin>' first." to stderr, exit 1.
    4. Iterate plugins via `discover_plugins "$PLUGINS_DIR"`. For each:
       - Skip if filter provided and doesn't match
       - Source the plugin's deploy.sh (if not already sourced)
       - Check if `plugin_${plugin}_status` function exists (using `type` or `declare -f`)
       - If exists: call it
       - If not: print plugin name as "not configured" (red)
    5. Print blank line at end for spacing

    **Rewrite cmd_list() with colour + installed status:**

    Per user decision: minimal output, no descriptions. Format:
    ```
    Available plugins:

      claude   checkmark installed
      git      x-mark not installed
    ```

    1. Call `init_colours`
    2. Source .env if exists
    3. For each plugin via discover_plugins:
       - Check if "installed" (has .env keys). Detection per plugin:
         - claude: CLAUDE_DEPLOY_TARGET is set and non-empty
         - git: GIT_USER_NAME is set and non-empty (or any GIT_* key)
       - Use a generic approach: source the plugin's deploy.sh, try calling the _load_config function, if it succeeds the plugin is configured
       - Actually simpler: just check if relevant env vars exist after sourcing .env
       - Print with colour: green + checkmark for installed, red + x-mark for not installed
    4. Use consistent column alignment with printf

    **Update main() routing:**
    - Remove the cmd_status stub if it was added in Plan 01
    - The `status)` case should call `cmd_status "${@:2}"`
    - Ensure list calls the rewritten cmd_list
  </action>
  <verify>
    1. `bash -n dotconfigs` — no syntax errors
    2. `./dotconfigs status` — shows plugin status (or "no configuration" error if no .env)
    3. `./dotconfigs list` — shows plugins with installed/not-installed symbols
    4. `./dotconfigs status | cat` — no ANSI escape codes in output (piped = plain text)
    5. `./dotconfigs list | cat` — no ANSI escape codes in output
    6. `./dotconfigs status claude` — filters to Claude plugin only
    7. All existing commands still work: `./dotconfigs help`, `./dotconfigs setup`, `./dotconfigs deploy claude`
  </verify>
  <done>
    `dotconfigs status` shows all plugins with per-file deployment state and drift detection. `dotconfigs status <plugin>` filters to one plugin. `dotconfigs list` shows plugins with coloured installed/not-installed status. All output is plain text when piped.
  </done>
</task>

</tasks>

<verification>
1. `./dotconfigs status` — shows per-file status for configured plugins with colours
2. `./dotconfigs status claude` — shows only Claude plugin status
3. `./dotconfigs list` — shows plugins with installed/not-installed
4. `./dotconfigs status | cat` — no ANSI escape codes
5. `./dotconfigs list | cat` — no ANSI escape codes
6. `./dotconfigs help status` — shows status command help
</verification>

<success_criteria>
- Status command shows per-file granularity with 5-state drift detection
- Status filters by plugin name when argument provided
- List command shows minimal plugin + installed status
- Colour output respects TTY detection
- Existing setup/deploy/project commands unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/07-integration-and-polish/07-02-SUMMARY.md`
</output>
