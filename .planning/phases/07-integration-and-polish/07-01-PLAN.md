---
phase: 07-integration-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/colours.sh
  - lib/symlinks.sh
  - dotconfigs
autonomous: true

must_haves:
  truths:
    - "Colour helpers produce ANSI codes when stdout is TTY and plain text when piped"
    - "check_file_state returns correct state for deployed, not-deployed, drifted-broken, drifted-foreign, drifted-wrong-target"
    - "dotconfigs help shows usage overview"
    - "dotconfigs help deploy shows deploy-specific help with --dry-run, --force, --interactive options"
    - "dotconfigs --help works as alias for help"
  artifacts:
    - path: "lib/colours.sh"
      provides: "TTY-aware ANSI colour helpers"
      contains: "init_colours"
    - path: "lib/symlinks.sh"
      provides: "Drift detection via check_file_state()"
      contains: "check_file_state"
    - path: "dotconfigs"
      provides: "Help system and routing for status, list, help commands"
      contains: "cmd_help"
  key_links:
    - from: "dotconfigs"
      to: "lib/colours.sh"
      via: "source in eager lib loading"
      pattern: "source.*lib/colours.sh"
    - from: "lib/symlinks.sh:check_file_state"
      to: "lib/symlinks.sh:is_dotconfigs_owned"
      via: "function call for ownership check"
      pattern: "is_dotconfigs_owned"
---

<objective>
Create shared infrastructure (colour helpers, drift detection) and help system for Phase 7.

Purpose: All subsequent plans depend on lib/colours.sh for coloured output and lib/symlinks.sh check_file_state for status reporting. The help system completes CLI-06 and updates routing for new commands (status, list, help).
Output: lib/colours.sh (new), lib/symlinks.sh (extended), dotconfigs (help system + updated routing)
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integration-and-polish/07-RESEARCH.md

@lib/symlinks.sh
@lib/discovery.sh
@dotconfigs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/colours.sh and extend lib/symlinks.sh with drift detection</name>
  <files>lib/colours.sh, lib/symlinks.sh</files>
  <action>
    **Create lib/colours.sh** (new file):
    - `init_colours()` function that checks `[[ -t 1 ]]` for TTY detection
    - When TTY: set COLOUR_GREEN='\033[32m', COLOUR_YELLOW='\033[33m', COLOUR_RED='\033[31m', COLOUR_RESET='\033[0m', SYMBOL_OK='checkmark', SYMBOL_DRIFT='delta', SYMBOL_MISSING='x-mark'
    - When not TTY: set all COLOUR_* to empty string, SYMBOL_OK='[OK]', SYMBOL_DRIFT='[DRIFT]', SYMBOL_MISSING='[MISSING]'
    - Helper functions: `colour_green()`, `colour_yellow()`, `colour_red()` that wrap text in colour codes using `printf` (not echo -e, for better portability)
    - No shebang (sourced library, not executable) per project convention
    - Use printf "%b" for colour output (more portable than echo -e across bash versions)

    **Extend lib/symlinks.sh** with `check_file_state()`:
    - Add function `check_file_state()` accepting: target_path, expected_source, dotconfigs_root
    - Return states via stdout: "deployed", "not-deployed", "drifted-broken", "drifted-foreign", "drifted-wrong-target"
    - Return codes: 0 (deployed OK), 1 (not deployed), 2 (drifted)
    - Logic:
      1. If target doesn't exist and isn't a dangling symlink: "not-deployed", return 1
      2. If target is a symlink but broken (target gone): "drifted-broken", return 2
      3. If target is a symlink and owned by dotconfigs: resolve absolute path (macOS: perl, Linux: readlink -f), compare to expected_source. Match = "deployed" return 0, mismatch = "drifted-wrong-target" return 2
      4. If target is a symlink but NOT owned by dotconfigs: "drifted-foreign", return 2
      5. If target is a regular file: "drifted-foreign", return 2
    - Use existing `is_dotconfigs_owned()` and the same macOS/Linux readlink pattern already in the file

    Also add a `_print_file_status()` helper to lib/colours.sh (or keep it in symlinks.sh alongside check_file_state):
    - Takes display_name and state string
    - Prints formatted coloured line based on state (deployed=green OK, drifted-*=yellow with reason, not-deployed=red MISSING)
    - This helper will be used by status command in Plan 02

    Bash 3.2 compatibility: no associative arrays, no namerefs, no ${var,,}. Use `[[ "$OSTYPE" == "darwin"* ]]` for platform detection (already proven pattern).
  </action>
  <verify>
    1. `bash -n lib/colours.sh` — no syntax errors
    2. `bash -n lib/symlinks.sh` — no syntax errors
    3. Source both files in a test: `bash -c 'source lib/colours.sh; source lib/symlinks.sh; init_colours; echo "colours loaded"; check_file_state /nonexistent/path /nonexistent/src /nonexistent/root; echo "state: $?"'` — should output "not-deployed" and exit 1
    4. Test TTY vs pipe: `bash -c 'source lib/colours.sh; init_colours; [[ -n "$COLOUR_GREEN" ]] && echo "TTY detected" || echo "no TTY"'` in terminal should show "TTY detected"
  </verify>
  <done>
    lib/colours.sh exists with init_colours(), colour_green(), colour_yellow(), colour_red(), _print_file_status(). lib/symlinks.sh contains check_file_state() that correctly returns all 5 states. Both files pass bash -n syntax check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add help system and update CLI routing in dotconfigs</name>
  <files>dotconfigs</files>
  <action>
    **Update dotconfigs CLI entry point:**

    1. Add `source "$SCRIPT_DIR/lib/colours.sh"` to the eager lib loading section (after validation.sh)

    2. Rewrite `show_usage()` to be the comprehensive help overview. Include:
       - All commands: setup, deploy, project, status, list, help
       - Deploy options: --interactive, --force, --dry-run
       - Brief examples section
       - Available plugins listed dynamically

    3. Add `show_command_help()` function with a case statement covering:
       - setup: usage, description, plugin list
       - deploy: usage, description, all flags (--interactive, --force, --dry-run), examples
       - project: usage, description, plugin filter mode, examples
       - status: usage, description, per-file detail explanation, examples
       - list: usage, description
       - Unknown command: error to stderr

    4. Add `cmd_help()` function:
       - No arg: call show_usage
       - With arg: call show_command_help "$1"

    5. Update `main()` case statement:
       - Add `status)` case that calls `cmd_status "${@:2}"` (function will be created in Plan 02, stub it as: `cmd_status() { echo "Status command not yet implemented" >&2; exit 1; }`)
       - Update `list)` case — keep existing cmd_list for now (Plan 02 rewrites it)
       - Add `help)` case that calls `cmd_help "${@:2}"`
       - Update `--help|-h)` to call show_usage
       - Support `dotconfigs deploy` (no plugin arg) — currently errors, update cmd_deploy to handle empty plugin by deploying all configured plugins. For now, add routing logic: if no plugin arg, iterate discover_plugins, source each deploy.sh, call plugin_${plugin}_deploy. Pass remaining flags through.

    6. Update `cmd_deploy()` to support:
       - No plugin arg: deploy all configured plugins (iterate discover_plugins, source each, call deploy)
       - Parse and pass through --force, --dry-run, --interactive flags to plugin deploy functions
       - The actual flag handling in plugin deploy functions will be enhanced in Plan 03

    Use heredoc pattern for all help text (standard CLI convention). Keep help text concise per user decision.
  </action>
  <verify>
    1. `bash -n dotconfigs` — no syntax errors
    2. `./dotconfigs help` — shows full usage with all commands
    3. `./dotconfigs help deploy` — shows deploy-specific help with flags
    4. `./dotconfigs help status` — shows status help
    5. `./dotconfigs --help` — same as `help`
    6. `./dotconfigs help nonexistent` — error message to stderr
    7. `./dotconfigs deploy` (without plugin) — attempts to deploy all (may fail if no .env, but shouldn't crash with unknown command error)
  </verify>
  <done>
    dotconfigs CLI has: help command with per-command detail, status command stub, deploy-all routing (no plugin = all plugins), sources lib/colours.sh. All existing commands (setup, deploy, project, list) still work unchanged.
  </done>
</task>

</tasks>

<verification>
1. `bash -n lib/colours.sh && bash -n lib/symlinks.sh && bash -n dotconfigs` — all files syntactically valid
2. `./dotconfigs help` — shows comprehensive usage
3. `./dotconfigs help deploy` — shows deploy help with --dry-run, --force
4. `./dotconfigs list` — still works (existing behaviour)
5. `./dotconfigs setup` — still shows error + usage (existing behaviour)
</verification>

<success_criteria>
- lib/colours.sh exists with TTY-aware colour helpers
- lib/symlinks.sh has check_file_state() returning 5 distinct states
- dotconfigs has help system with per-command help
- dotconfigs routes "deploy" with no plugin to deploy-all
- All existing CLI commands still function
</success_criteria>

<output>
After completion, create `.planning/phases/07-integration-and-polish/07-01-SUMMARY.md`
</output>
