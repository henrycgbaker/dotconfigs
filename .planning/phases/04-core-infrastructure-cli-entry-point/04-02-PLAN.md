---
phase: 04-core-infrastructure-cli-entry-point
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - dotconfigs
  - plugins/claude/setup.sh
  - plugins/claude/deploy.sh
autonomous: true

must_haves:
  truths:
    - "dotconfigs setup claude routes to and executes plugin_claude_setup from plugins/claude/setup.sh"
    - "dotconfigs deploy claude routes to and executes plugin_claude_deploy from plugins/claude/deploy.sh"
    - "dotconfigs list shows available plugins discovered from plugins/*/ directories"
    - "dotconfigs (no args) and dotconfigs --help show usage with available plugins"
    - "dotconfigs setup nonexistent prints error with list of available plugins and exits non-zero"
    - "Adding a new plugin requires only creating plugins/<name>/setup.sh and deploy.sh — zero changes to entry point"
    - "All code is bash 3.2 compatible"
  artifacts:
    - path: "dotconfigs"
      provides: "CLI entry point with subcommand routing"
      contains: "cmd_setup"
    - path: "plugins/claude/setup.sh"
      provides: "Claude plugin setup stub"
      contains: "plugin_claude_setup"
    - path: "plugins/claude/deploy.sh"
      provides: "Claude plugin deploy stub"
      contains: "plugin_claude_deploy"
  key_links:
    - from: "dotconfigs"
      to: "lib/wizard.sh"
      via: "source at startup (eager)"
      pattern: "source.*lib/wizard.sh"
    - from: "dotconfigs"
      to: "lib/discovery.sh"
      via: "source at startup (eager)"
      pattern: "source.*lib/discovery.sh"
    - from: "dotconfigs"
      to: "plugins/claude/setup.sh"
      via: "source on-demand (lazy) in cmd_setup"
      pattern: "source.*PLUGINS_DIR.*plugin.*setup.sh"
    - from: "dotconfigs"
      to: "plugins/claude/deploy.sh"
      via: "source on-demand (lazy) in cmd_deploy"
      pattern: "source.*PLUGINS_DIR.*plugin.*deploy.sh"
---

<objective>
Create the `dotconfigs` CLI entry point and plugin stub files so the full routing chain works end-to-end.

Purpose: This is the skeleton onto which plugins are mounted. After this plan, `dotconfigs setup claude` routes through to a real (stub) plugin function, proving the entire architecture works.
Output: Executable `dotconfigs` script at repo root, stub plugin files in `plugins/claude/`.
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-infrastructure-cli-entry-point/04-RESEARCH.md
@.planning/phases/04-core-infrastructure-cli-entry-point/04-01-SUMMARY.md
@lib/wizard.sh
@lib/symlinks.sh
@lib/discovery.sh
@lib/validation.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dotconfigs CLI entry point</name>
  <files>dotconfigs</files>
  <action>
    Create `dotconfigs` at the repo root. This is an executable bash script.

    **Structure** (follow the research code example in 04-RESEARCH.md closely):

    1. **Header and setup:**
       - Shebang: `#!/bin/bash`
       - `set -e`
       - `SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"`
       - `PLUGINS_DIR="$SCRIPT_DIR/plugins"`
       - `ENV_FILE="$SCRIPT_DIR/.env"`

    2. **Eager lib loading** — Source all four lib files:
       ```
       source "$SCRIPT_DIR/lib/wizard.sh"
       source "$SCRIPT_DIR/lib/symlinks.sh"
       source "$SCRIPT_DIR/lib/discovery.sh"
       source "$SCRIPT_DIR/lib/validation.sh"
       ```

    3. **show_usage()** — Print usage help to stdout. Include:
       - Title line: `dotconfigs — Unified configuration management`
       - Usage section with: `setup <plugin>`, `deploy <plugin>`, `list`, `--help`
       - Examples section with: `dotconfigs setup claude`, `dotconfigs deploy git`, `dotconfigs list`
       - Dynamic "Available plugins:" section using discover_plugins (loop prints each on its own line with "  - " prefix)

    4. **cmd_setup(plugin, ...)** — Route to plugin setup:
       - If no plugin arg provided, print "Error: Plugin name required" to stderr, show usage, exit 1
       - Validate with `plugin_exists "$plugin"`. On failure: print "Error: Plugin '$plugin' not found" to stderr, blank line, call `list_available_plugins`, exit 1
       - Source `$PLUGINS_DIR/$plugin/setup.sh` (lazy load)
       - Call `"plugin_${plugin}_setup" "$@"` (forward remaining args)

    5. **cmd_deploy(plugin, ...)** — Route to plugin deploy:
       - Same validation pattern as cmd_setup
       - Source `$PLUGINS_DIR/$plugin/deploy.sh` (lazy load)
       - Call `"plugin_${plugin}_deploy" "$@"`

    6. **cmd_list()** — List available plugins:
       - Print "Available plugins:"
       - Loop over discover_plugins output, for each plugin:
         - Check for `$PLUGINS_DIR/$plugin/DESCRIPTION` file
         - If exists, read first line as description
         - Print formatted: `printf "  %-12s %s\n" "$plugin" "$desc"`

    7. **main(args)** — Top-level dispatch:
       - If no args: show_usage, exit 0
       - case on $1:
         - `setup|deploy`) call `cmd_"$1" "${@:2}"` ;;
         - `list`) call `cmd_list` ;;
         - `--help|-h|help`) show_usage, exit 0 ;;
         - `*`) print "Error: Unknown command '$1'" to stderr, blank line, show_usage, exit 1 ;;
       - Call `main "$@"` at end of script

    8. **Make executable:** `chmod +x dotconfigs`

    **Bash 3.2 notes:**
    - `"${@:2}"` (array slicing) IS valid in bash 3.2
    - Use `tr '[:upper:]' '[:lower:]'` if any case conversion needed (there shouldn't be any in the entry point)
    - Do NOT use associative arrays, namerefs, or `${var,,}`
  </action>
  <verify>
    - `test -x dotconfigs && echo "executable"` returns "executable"
    - `bash -n dotconfigs && echo "syntax ok"` returns "syntax ok"
    - `grep -c "source.*lib/" dotconfigs` returns 4 (all four lib files sourced)
    - `grep -c "cmd_setup\|cmd_deploy\|cmd_list\|show_usage\|main" dotconfigs` returns at least 5 (all functions defined)
    - `grep -c 'declare -A\|local -n\|${.*,,}' dotconfigs` returns 0
  </verify>
  <done>dotconfigs is executable, has valid syntax, sources all 4 lib files eagerly, routes setup/deploy/list/help subcommands, bash 3.2 compatible</done>
</task>

<task type="auto">
  <name>Task 2: Create plugin stubs and verify end-to-end routing</name>
  <files>plugins/claude/setup.sh, plugins/claude/deploy.sh</files>
  <action>
    **Create plugin directory:**
    - `plugins/` directory at repo root
    - `plugins/claude/` subdirectory

    **plugins/claude/setup.sh** — Stub that proves routing works:
    ```bash
    # plugins/claude/setup.sh — Claude Code setup wizard
    # Sourced by dotconfigs entry point. Do not execute directly.
    # Full implementation in Phase 5.

    plugin_claude_setup() {
        echo "Claude setup wizard"
        echo "(stub — full implementation in Phase 5)"
        echo ""
        echo "This will configure:"
        echo "  - CLAUDE.md deployment"
        echo "  - settings.json"
        echo "  - Claude Code hooks"
        echo "  - Slash commands"
        return 0
    }
    ```

    **plugins/claude/deploy.sh** — Stub that proves routing works:
    ```bash
    # plugins/claude/deploy.sh — Claude Code configuration deployment
    # Sourced by dotconfigs entry point. Do not execute directly.
    # Full implementation in Phase 5.

    plugin_claude_deploy() {
        echo "Claude deploy"
        echo "(stub — full implementation in Phase 5)"
        echo ""
        echo "This will deploy:"
        echo "  - CLAUDE.md to ~/.claude/"
        echo "  - settings.json to ~/.claude/"
        echo "  - Hooks to ~/.claude/hooks/"
        echo "  - Commands to ~/.claude/commands/"
        return 0
    }
    ```

    No shebang on either file (sourced, not executed directly).

    **End-to-end verification tests** (run all of these):

    1. `./dotconfigs setup claude` — Should print "Claude setup wizard" stub output, exit 0
    2. `./dotconfigs deploy claude` — Should print "Claude deploy" stub output, exit 0
    3. `./dotconfigs list` — Should show "Available plugins:" with "claude" listed
    4. `./dotconfigs` — Should show usage with "Available plugins:" including "claude"
    5. `./dotconfigs --help` — Should show usage
    6. `./dotconfigs setup nonexistent` — Should print error, list available plugins, exit non-zero
    7. `./dotconfigs badcommand` — Should print error, show usage, exit non-zero

    **Extensibility proof** — Create a temporary test plugin to prove zero-change extensibility:
    1. `mkdir -p plugins/test-plugin`
    2. Create `plugins/test-plugin/setup.sh` with `plugin_test-plugin_setup() { echo "test works"; }`
       NOTE: bash function names with hyphens are not valid. Instead use underscored name:
       Actually, plugin names with hyphens won't work with `"plugin_${plugin}_setup"` dispatch because bash function names cannot contain hyphens. This is fine — document that plugin names must be alphanumeric/underscores only. The test plugin should use `plugins/testplugin/` with `plugin_testplugin_setup`.
    3. Create `plugins/testplugin/setup.sh` with: `plugin_testplugin_setup() { echo "test plugin works"; }`
    4. Create `plugins/testplugin/deploy.sh` with: `plugin_testplugin_deploy() { echo "test deploy works"; }`
    5. Run `./dotconfigs list` — Should show both "claude" and "testplugin"
    6. Run `./dotconfigs setup testplugin` — Should print "test plugin works"
    7. Clean up: `rm -rf plugins/testplugin`

    All tests must pass.
  </action>
  <verify>
    - `./dotconfigs setup claude 2>&1 | head -1` outputs "Claude setup wizard"
    - `./dotconfigs deploy claude 2>&1 | head -1` outputs "Claude deploy"
    - `./dotconfigs list 2>&1 | grep -c "claude"` returns at least 1
    - `./dotconfigs setup nonexistent 2>&1 | grep -c "not found"` returns 1
    - `./dotconfigs setup nonexistent; echo "exit: $?"` shows non-zero exit code
    - `./dotconfigs badcommand 2>&1 | grep -c "Unknown command"` returns 1
    - `bash -n plugins/claude/setup.sh && bash -n plugins/claude/deploy.sh && echo "syntax ok"`
    - `grep -c 'declare -A\|local -n\|${.*,,}' plugins/claude/setup.sh plugins/claude/deploy.sh` returns 0
  </verify>
  <done>plugins/claude/ exists with setup.sh and deploy.sh stubs containing plugin_claude_setup and plugin_claude_deploy functions. End-to-end routing verified: setup/deploy/list/help/error all work. Extensibility verified: adding a directory with setup.sh+deploy.sh makes a new plugin appear without entry point changes.</done>
</task>

</tasks>

<verification>
Full end-to-end verification of Phase 4 success criteria:

1. `./dotconfigs setup claude` — routes to and executes plugins/claude/setup.sh
2. `./dotconfigs deploy claude` — routes to and executes plugins/claude/deploy.sh
3. Extensibility: create plugins/testplugin/ with setup.sh+deploy.sh, `./dotconfigs setup testplugin` works, clean up
4. `test -f lib/wizard.sh && test -f lib/symlinks.sh && test -f lib/discovery.sh && echo "lib complete"` — all lib files exist
5. `grep -rn 'declare -A\|local -n\|${.*,,}\|${.*^^}' lib/ plugins/ dotconfigs && echo "BASH4 FOUND" || echo "bash 3.2 ok"` — no bash 4+ features
6. `./dotconfigs setup nonexistent 2>&1 | grep "not found"` — clear error with plugin list
</verification>

<success_criteria>
- `dotconfigs` is executable at repo root with working subcommand routing
- `dotconfigs setup claude` prints stub output and exits 0
- `dotconfigs deploy claude` prints stub output and exits 0
- `dotconfigs list` shows "claude" as available plugin
- `dotconfigs setup nonexistent` shows error + available plugins, exits non-zero
- `dotconfigs badcommand` shows error + usage, exits non-zero
- plugins/claude/ has setup.sh with plugin_claude_setup and deploy.sh with plugin_claude_deploy
- Zero entry point changes needed to add a new plugin (proven by temporary test plugin)
- All files bash 3.2 compatible
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-infrastructure-cli-entry-point/04-02-SUMMARY.md`
</output>
