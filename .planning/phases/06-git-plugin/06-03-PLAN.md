---
phase: 06-git-plugin
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - plugins/git/deploy.sh
  - plugins/git/project.sh
  - plugins/git/DESCRIPTION
autonomous: true

must_haves:
  truths:
    - "dotconfigs deploy git applies identity, workflow settings, aliases, and hooks to git config"
    - "Deploy warns on configuration drift before overwriting"
    - "Hooks deploy per-project by default via dotconfigs project"
    - "Global hook deployment via core.hooksPath is opt-in with conflict warning"
    - "Alias drift detection warns when existing alias differs from .env definition"
    - "dotconfigs project git <path> copies hooks to .git/hooks/ and offers per-repo identity"
    - "dotconfigs list shows the git plugin"
  artifacts:
    - path: "plugins/git/deploy.sh"
      provides: "Git config deployment with drift detection"
      contains: "plugin_git_deploy"
      min_lines: 80
    - path: "plugins/git/project.sh"
      provides: "Per-project hook deployment and optional identity"
      contains: "plugin_git_project"
      min_lines: 30
    - path: "plugins/git/DESCRIPTION"
      provides: "Plugin metadata for dotconfigs list"
  key_links:
    - from: "plugins/git/deploy.sh"
      to: ".env"
      via: "source and read GIT_* keys"
      pattern: "GIT_USER_NAME|GIT_PULL_REBASE|GIT_ALIASES_ENABLED"
    - from: "plugins/git/deploy.sh"
      to: "git config --global"
      via: "git config commands"
      pattern: "git config --global"
    - from: "plugins/git/project.sh"
      to: "plugins/git/hooks/"
      via: "cp hook files to .git/hooks/"
      pattern: "cp.*hooks.*\\.git/hooks"
    - from: "plugins/git/deploy.sh"
      to: "plugins/git/hooks/"
      via: "copy hooks for global deployment"
      pattern: "core\\.hooksPath"
---

<objective>
Create git plugin deploy logic, per-project support, and plugin metadata.

Purpose: This completes the git plugin by adding the deployment that reads .env and applies git configuration, plus per-project hook deployment via `dotconfigs project`, and the DESCRIPTION file for `dotconfigs list`.

Output: `plugins/git/deploy.sh`, `plugins/git/project.sh`, `plugins/git/DESCRIPTION`
</objective>

<execution_context>
@/Users/henrybaker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henrybaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@plugins/claude/deploy.sh
@plugins/claude/project.sh
@lib/wizard.sh
@lib/symlinks.sh
@.planning/phases/06-git-plugin/06-01-SUMMARY.md
@.planning/phases/06-git-plugin/06-02-SUMMARY.md
@.planning/phases/06-git-plugin/06-CONTEXT.md
@.planning/phases/06-git-plugin/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create git plugin deploy logic</name>
  <files>plugins/git/deploy.sh</files>
  <action>
Create `plugins/git/deploy.sh` following the established plugin pattern from `plugins/claude/deploy.sh`.

**File structure:**
```
# plugins/git/deploy.sh -- Git configuration deployment
# Sourced by dotconfigs entry point. Do not execute directly.
```

No shebang (sourced library).

**Top-level variables** (same pattern as Claude deploy):
```bash
PLUGIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTCONFIGS_ROOT="$(cd "$PLUGIN_DIR/../.." && pwd)"
ENV_FILE="$DOTCONFIGS_ROOT/.env"
```

**Internal helper functions** (prefix with `_git_`):

1. `_git_load_config()` -- Load and validate .env
   - Source .env file
   - Verify at least one GIT_* key exists (not a hard failure -- some sections may be unconfigured)
   - Parse GIT_ALIASES_ENABLED into an array (space-separated to array, same pattern as Claude's `_claude_load_config`)
   - Return 1 with error if .env doesn't exist

2. `_git_detect_drift()` -- Check for configuration drift
   - Compare .env values with current `git config --global` values for:
     - user.name vs GIT_USER_NAME
     - user.email vs GIT_USER_EMAIL
     - pull.rebase vs GIT_PULL_REBASE
     - push.default vs GIT_PUSH_DEFAULT
     - fetch.prune vs GIT_FETCH_PRUNE
     - init.defaultBranch vs GIT_INIT_DEFAULT_BRANCH
   - For each mismatch where both .env value and current git config are non-empty, print a warning line showing current vs new value
   - Return 0 if drift detected, 1 if no drift
   - Pattern from research: `echo "  drift: setting.name: 'current' -> 'new'"`

3. `_git_deploy_identity()` -- Apply identity settings
   - If GIT_USER_NAME is set and non-empty: `git config --global user.name "$GIT_USER_NAME"`
   - If GIT_USER_EMAIL is set and non-empty: `git config --global user.email "$GIT_USER_EMAIL"`
   - Print confirmation for each applied setting

4. `_git_deploy_workflow()` -- Apply workflow settings
   - For each setting, only apply if the .env key is set and non-empty:
     - GIT_PULL_REBASE -> `git config --global pull.rebase "$GIT_PULL_REBASE"`
     - GIT_PUSH_DEFAULT -> `git config --global push.default "$GIT_PUSH_DEFAULT"`
     - GIT_FETCH_PRUNE -> `git config --global fetch.prune "$GIT_FETCH_PRUNE"`
     - GIT_INIT_DEFAULT_BRANCH -> `git config --global init.defaultBranch "$GIT_INIT_DEFAULT_BRANCH"`
     - GIT_RERERE_ENABLED -> `git config --global rerere.enabled "$GIT_RERERE_ENABLED"` (only if "true")
     - GIT_DIFF_ALGORITHM -> `git config --global diff.algorithm "$GIT_DIFF_ALGORITHM"` (only if non-empty)
     - GIT_HELP_AUTOCORRECT -> `git config --global help.autocorrect "$GIT_HELP_AUTOCORRECT"` (only if non-empty)
   - Print confirmation for each

5. `_git_deploy_alias()` -- Deploy a single alias with drift warning
   - Args: alias_name, alias_command
   - Check existing: `git config --global --get "alias.$alias_name"`
   - If exists with different definition: print drift warning ("alias '$name' exists with different definition")
   - Set alias: `git config --global "alias.$alias_name" "$alias_command"`
   - Print confirmation

6. `_git_deploy_aliases()` -- Deploy all enabled aliases
   - Read GIT_ALIASES_ENABLED array
   - For each enabled alias name, look up its definition from `GIT_ALIAS_<UPPERCASE_NAME>` env var
   - If the env var exists and is non-empty, use that definition
   - **If `GIT_ALIAS_<NAME>` env var is missing** (alias in enabled list but no definition key), **fall back to a hardcoded default lookup table within this function.** The table is a case statement mapping the 6 default alias names to their definitions:
     ```
     case "$alias_name" in
       unstage) default_cmd="reset HEAD --" ;;
       last)    default_cmd="log -1 HEAD" ;;
       lg)      default_cmd="log --oneline --graph --all --decorate" ;;
       amend)   default_cmd="commit --amend --no-edit" ;;
       undo)    default_cmd="reset HEAD~1 --mixed" ;;
       wip)     default_cmd="commit -am 'WIP'" ;;
       *)       echo "Warning: No definition found for alias '$alias_name', skipping"; continue ;;
     esac
     ```
     For unknown alias names not in the default table (custom aliases with missing definitions), print a warning and skip.
   - Call `_git_deploy_alias` for each resolved alias name + command pair

7. `_git_deploy_hooks_global()` -- Deploy hooks globally via core.hooksPath
   - Create target directory: `$HOME/.dotconfigs/git-hooks/`
   - Copy all hooks from `$PLUGIN_DIR/hooks/` to target directory
   - `chmod +x` each hook
   - Set `git config --global core.hooksPath "$HOME/.dotconfigs/git-hooks/"`
   - Print warning: "Global hooks override per-project hooks in .git/hooks/"

**Main function `plugin_git_deploy()`:**
- Call `_git_load_config` -- return 1 on failure
- Print deployment header (same style as Claude plugin)
- Call `_git_detect_drift`. If drift detected, prompt with `wizard_yesno "Deploy will overwrite. Continue?" "y"`. If no, return 1.
- Section 1: Deploy identity -- call `_git_deploy_identity`
- Section 2: Deploy workflow settings -- call `_git_deploy_workflow`
- Section 3: Deploy aliases -- call `_git_deploy_aliases`
- Section 4: Deploy hooks based on scope:
  - If `GIT_HOOKS_SCOPE` is "global": call `_git_deploy_hooks_global`
  - If "project" (default): print message "Hooks configured for per-project deployment. Run 'dotconfigs project git <path>' to deploy hooks to a specific repo."
- Print completion footer (same style as Claude plugin)

**Bash 3.2 compatibility:** No associative arrays, no namerefs. Use simple arrays and string manipulation. For looking up alias definitions by name, use the case statement pattern shown above.
  </action>
  <verify>
Run: `bash -n plugins/git/deploy.sh` should exit 0
Run: `grep -c "plugin_git_deploy" plugins/git/deploy.sh` should return at least 1
Run: `grep -c "git config --global" plugins/git/deploy.sh` should be > 5
Run: `grep -c "_git_detect_drift" plugins/git/deploy.sh` should be >= 2
Run: `grep -c "_git_deploy_alias" plugins/git/deploy.sh` should be >= 2
Run: `grep -c "core.hooksPath" plugins/git/deploy.sh` should be >= 1
Run: `grep -c "wizard_yesno" plugins/git/deploy.sh` should be >= 1 (drift confirmation)
Run: `grep -c "default_cmd\|case.*alias_name" plugins/git/deploy.sh` should be >= 1 (default lookup table)
  </verify>
  <done>plugins/git/deploy.sh exists with plugin_git_deploy() that applies identity, workflow settings, aliases via git config --global, deploys hooks globally or defers to project.sh, and warns on drift before overwriting. Alias deployment uses GIT_ALIAS_* env vars with hardcoded default lookup table as fallback for the 6 built-in aliases. Valid bash 3.2 syntax.</done>
</task>

<task type="auto">
  <name>Task 2: Create git plugin project support and metadata</name>
  <files>plugins/git/project.sh, plugins/git/DESCRIPTION</files>
  <action>
**plugins/git/project.sh:**

Create following the pattern from `plugins/claude/project.sh`.

```
# plugins/git/project.sh -- Git per-project configuration
# Sourced by dotconfigs entry point. Do not execute directly.
```

No shebang (sourced library).

**Main function `plugin_git_project()`:**
- Receives `project_path` as first argument (same interface as Claude plugin)
- Print header (same style as Claude plugin but "Git Plugin: Project Setup")
- Validate the path is a git repo using `validate_git_repo "$project_path"` (from lib/validation.sh)

**Step 1: Deploy hooks to .git/hooks/**
- For each hook file in `$PLUGIN_DIR/hooks/`:
  - Check if `.git/hooks/<hook_name>` already exists
  - If exists and NOT owned by dotconfigs (check if it's a different file): warn "Hook '<name>' already exists in this repo" and ask `wizard_yesno "Overwrite?" "n"`
  - Copy hook: `cp "$PLUGIN_DIR/hooks/$hook_name" "$project_path/.git/hooks/$hook_name"`
  - Set executable: `chmod +x "$project_path/.git/hooks/$hook_name"`
  - Print confirmation

**Step 2: Per-repo identity (opt-in, Claude's discretion -- include it)**
- Ask: `wizard_yesno "Configure project-specific git identity?" "n"`
- If yes:
  - Pre-fill from current repo config: `git -C "$project_path" config --local --get user.name`
  - Use `wizard_prompt` for name and email
  - Apply: `git -C "$project_path" config --local user.name "$name"` and email
  - Print confirmation
- If no: skip (global identity applies)

NOTE: This is NOT the deferred "Per-repo git project support" idea. That was about extending dotconfigs project with git identity overrides as a full feature. This is simply an opt-in prompt during project setup -- minimal and appropriate.

**Step 3: Deploy hooks.conf for git plugin settings (optional)**
- If the project has `.claude/hooks.conf`, note that conventional commit settings can be overridden there
- Print a note about per-project configuration options

Print completion footer.

**plugins/git/DESCRIPTION:**

Create a single-line description file:
```
Git configuration: identity, workflow settings, aliases, and hooks
```

This file is read by `dotconfigs list` (see `cmd_list()` in the entry point).
  </action>
  <verify>
Run: `bash -n plugins/git/project.sh` should exit 0
Run: `grep -c "plugin_git_project" plugins/git/project.sh` should return at least 1
Run: `grep -c "chmod +x" plugins/git/project.sh` should be >= 1
Run: `grep -c ".git/hooks" plugins/git/project.sh` should be >= 1
Run: `test -f plugins/git/DESCRIPTION && echo "exists"` should print "exists"
Run: `cat plugins/git/DESCRIPTION` should show single-line description
  </verify>
  <done>plugins/git/project.sh exists with plugin_git_project() that deploys hooks to .git/hooks/, offers optional per-repo identity, and handles existing hook conflicts. DESCRIPTION file exists for dotconfigs list.</done>
</task>

</tasks>

<verification>
1. Full plugin discovery works: `ls plugins/git/{setup,deploy,project}.sh plugins/git/DESCRIPTION` all exist
2. All three .sh files pass `bash -n` syntax check
3. deploy.sh applies git config and has drift detection
4. deploy.sh alias deployment has hardcoded default lookup table for fallback
5. project.sh copies hooks to .git/hooks/ with conflict handling
6. DESCRIPTION file is readable
7. The CLI should now route `dotconfigs setup git`, `dotconfigs deploy git`, `dotconfigs project git .` to the git plugin (the entry point auto-discovers based on directory existence + setup.sh + deploy.sh)
</verification>

<success_criteria>
- `dotconfigs deploy git` reads .env GIT_* keys and applies them via git config --global
- Drift detection warns before overwriting changed values
- Alias deployment resolves definitions from GIT_ALIAS_* env vars with case-statement fallback for default aliases
- `dotconfigs project git <path>` copies hooks to .git/hooks/ with chmod +x
- Per-repo identity is offered as opt-in during project setup
- `dotconfigs list` shows the git plugin with its description
- All files are bash 3.2 compatible
</success_criteria>

<output>
After completion, create `.planning/phases/06-git-plugin/06-03-SUMMARY.md`
</output>
