#!/bin/bash
# dotconfigs — Unified configuration management CLI entry point

set -e

# Resolve symlinks to find real script location (bash 3.2 compatible)
_source="${BASH_SOURCE[0]}"
while [[ -L "$_source" ]]; do
    _dir="$(cd "$(dirname "$_source")" && pwd)"
    _source="$(readlink "$_source")"
    [[ "$_source" != /* ]] && _source="$_dir/$_source"
done
SCRIPT_DIR="$(cd "$(dirname "$_source")" && pwd)"
unset _source _dir
PLUGINS_DIR="$SCRIPT_DIR/plugins"
ENV_FILE="$SCRIPT_DIR/.env"
GLOBAL_CONFIG="$SCRIPT_DIR/global.json"

# Source shared libraries eagerly (small files)
source "$SCRIPT_DIR/lib/wizard.sh"
source "$SCRIPT_DIR/lib/symlinks.sh"
source "$SCRIPT_DIR/lib/discovery.sh"
source "$SCRIPT_DIR/lib/validation.sh"
source "$SCRIPT_DIR/lib/colours.sh"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/deploy.sh"

show_usage() {
    cat <<EOF
dotconfigs — Unified configuration management

Usage:
  dotconfigs setup                              Initialize tool (PATH symlinks)
  dotconfigs global-configs <plugin>            Configure plugin defaults (.env)
  dotconfigs project-init [path]                Scaffold per-project config
  dotconfigs project [path] [options]           Deploy per-project configuration
  dotconfigs deploy [group] [options]           Deploy configuration to filesystem
  dotconfigs status [plugin]                    Show deployment status
  dotconfigs list                               List available plugins
  dotconfigs help [command]                     Show help for command
  dotconfigs --help                             Show this help

Commands:
  setup           Initialize dotconfigs tool (one-time setup)
  global-configs  Interactive wizard to configure plugin defaults (.env)
  project-init    Scaffold per-project configuration (alias: project-configs)
  project         Deploy per-project configuration from .dotconfigs/project.json
                  Options: --force, --dry-run
  deploy          Deploy configuration from global.json
                  Options: --force, --dry-run
                  Without group: deploys all groups
  status          Check deployment status and drift detection
  list            List all available plugins
  help            Show detailed help for specific command

Examples:
  dotconfigs setup                      Initialize dotconfigs
  dotconfigs global-configs claude      Configure Claude defaults
  dotconfigs project-init .             Scaffold project config
  dotconfigs project .                  Deploy project configuration
  dotconfigs deploy                     Deploy all configurations
  dotconfigs deploy git                 Deploy git configuration only
  dotconfigs deploy --dry-run           Preview all deployments
  dotconfigs status                     Show status of all plugins
  dotconfigs list                       Show all plugins

Available plugins:
EOF
    while IFS= read -r plugin; do
        echo "  - $plugin"
    done < <(discover_plugins "$PLUGINS_DIR")
}

show_command_help() {
    local command="$1"

    case "$command" in
        setup)
            cat <<EOF
dotconfigs setup — Initialize dotconfigs tool

Usage:
  dotconfigs setup

Description:
  One-time initialization of dotconfigs.
  Configures deploy target directory and adds tool to PATH.
  Run this once before configuring individual plugins.

Example:
  dotconfigs setup    Initialize dotconfigs
EOF
            ;;
        global-configs)
            cat <<EOF
dotconfigs global-configs — Configure plugin defaults

Usage:
  dotconfigs global-configs <plugin>

Description:
  Runs the interactive setup wizard for the specified plugin.
  Creates or updates .env file with plugin configuration.
  These are global defaults applied across all projects.

Available plugins:
EOF
            while IFS= read -r plugin; do
                echo "  - $plugin"
            done < <(discover_plugins "$PLUGINS_DIR")
            cat <<EOF

Examples:
  dotconfigs global-configs claude    Configure Claude Code settings
  dotconfigs global-configs git       Configure git hooks and identity
EOF
            ;;
        project-configs|project-init)
            cat <<EOF
dotconfigs project-init — Scaffold per-project configuration

Usage:
  dotconfigs project-init [path]

Description:
  Creates .dotconfigs/project.json at the target project path.
  The config file specifies which hooks, settings, and files to deploy.
  Source paths resolve against dotconfigs repo root.
  Target paths resolve relative to the project root.

  After creating the config, edit it, then run: dotconfigs project <path>

Examples:
  dotconfigs project-init .              Create config for current project
  dotconfigs project-init ~/myrepo       Create config for specific project
EOF
            ;;
        project)
            cat <<EOF
dotconfigs project — Deploy per-project configuration

Usage:
  dotconfigs project [path] [--dry-run] [--force]

Description:
  Reads .dotconfigs/project.json from the target project and deploys
  all configured modules (hooks, settings, etc.).
  Source paths resolve against dotconfigs repo root.
  Target paths resolve relative to the project root.

  Auto-excludes .dotconfigs/ in .git/info/exclude.

Options:
  --dry-run       Preview changes without deploying
  --force         Overwrite all conflicts without prompting

Examples:
  dotconfigs project .                   Deploy current project config
  dotconfigs project ~/myrepo            Deploy specific project config
  dotconfigs project . --dry-run         Preview deployment
EOF
            ;;
        deploy)
            cat <<EOF
dotconfigs deploy — Deploy configuration to filesystem

Usage:
  dotconfigs deploy [group] [options]

Description:
  Deploys configuration from global.json to the filesystem.
  Without a group name, deploys all groups.

Options:
  --force          Overwrite all conflicts without prompting
  --dry-run        Preview changes without deploying

Conflicts (files not managed by dotconfigs) prompt for resolution:
overwrite, skip, backup, or diff. Use --force to skip prompts.

Examples:
  dotconfigs deploy                      Deploy all groups (prompts on conflicts)
  dotconfigs deploy claude               Deploy claude group only
  dotconfigs deploy git                  Deploy git group only
  dotconfigs deploy --force              Deploy all, overwrite conflicts
  dotconfigs deploy --dry-run            Preview all deployments
EOF
            ;;
        status)
            cat <<EOF
dotconfigs status — Check deployment status

Usage:
  dotconfigs status [plugin]

Description:
  Shows deployment status for plugin configuration files.
  Detects drift (broken symlinks, foreign files, wrong targets).
  Without a plugin name, shows status for all plugins.

States:
  ✓  Deployed      Symlink correctly points to dotconfigs
  △  Drifted       Broken symlink, foreign file, or wrong target
  ✗  Not deployed  File doesn't exist

Examples:
  dotconfigs status           Show status of all plugins
  dotconfigs status claude    Show Claude plugin status only
EOF
            ;;
        list)
            cat <<EOF
dotconfigs list — List available plugins

Usage:
  dotconfigs list

Description:
  Lists all available plugins with descriptions.

Example:
  dotconfigs list
EOF
            ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            echo "" >&2
            echo "Available commands: setup, global-configs, project-init, deploy, status, list, help" >&2
            return 1
            ;;
    esac
}

cmd_help() {
    if [[ $# -eq 0 ]]; then
        show_usage
    else
        show_command_help "$1"
    fi
}

cmd_setup_legacy() {
    echo "Warning: 'dotconfigs setup <plugin>' is deprecated." >&2
    echo "Use: 'dotconfigs global-configs $1' instead." >&2
    return 1
}

cmd_setup() {
    init_colours

    echo ""
    echo "========================================================="
    echo "  dotconfigs - First Time Setup"
    echo "========================================================="
    echo ""

    # Initialize global.json from template if it doesn't exist
    if [[ ! -f "$GLOBAL_CONFIG" ]]; then
        if [[ -f "$SCRIPT_DIR/global.template.json" ]]; then
            cp "$SCRIPT_DIR/global.template.json" "$GLOBAL_CONFIG"
            echo "Created global.json from template"
        else
            echo "Warning: global.template.json not found" >&2
        fi
    fi

    # Save version marker
    wizard_save_env "$ENV_FILE" "DOTCONFIGS_VERSION" "2.0"

    # Create PATH symlinks (dotconfigs + dots)
    echo "Setting up PATH availability..."
    _create_path_symlink "false" "false"

    echo ""
    echo "Setup complete."
    echo ""
    echo "Next steps — configure your plugins:"
    while IFS= read -r p; do
        echo "  dotconfigs global-configs $p"
    done < <(discover_plugins "$PLUGINS_DIR")
    echo ""
    echo "Then deploy with: dotconfigs deploy"
    echo ""
}

cmd_global_configs() {
    local plugin=$1

    if [[ -z "$plugin" ]]; then
        echo "Error: Plugin name required" >&2
        echo "Usage: dotconfigs global-configs <plugin>" >&2
        echo "" >&2
        list_available_plugins
        exit 1
    fi

    if ! plugin_exists "$plugin"; then
        echo "Error: Plugin '$plugin' not found" >&2
        list_available_plugins
        exit 1
    fi

    # Load and run plugin wizard
    source "$PLUGINS_DIR/$plugin/setup.sh"
    "plugin_${plugin}_setup" "$@"
}

_create_path_symlink() {
    local dry_run="$1"
    local force_mode="$2"

    # Determine symlink target: prefer ~/.local/bin, fall back to /usr/local/bin
    local target=""
    if [[ -d "$HOME/.local/bin" ]]; then
        target="$HOME/.local/bin/dotconfigs"
    elif [[ -d "/usr/local/bin" ]]; then
        target="/usr/local/bin/dotconfigs"
    else
        # Neither exists, try to create ~/.local/bin
        if mkdir -p "$HOME/.local/bin" 2>/dev/null; then
            target="$HOME/.local/bin/dotconfigs"
        else
            echo "Warning: Cannot create ~/.local/bin and /usr/local/bin not found" >&2
            echo "To make dotconfigs available on PATH, add to your shell profile:" >&2
            echo "  export PATH=\"$SCRIPT_DIR:\$PATH\"" >&2
            return 0
        fi
    fi

    # Dry-run mode
    if [[ "$dry_run" == "true" ]]; then
        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
            echo "CLI availability:"
            echo "  Unchanged: $target → $SCRIPT_DIR/dotconfigs"
            local dots_target="$(dirname "$target")/dots"
            if [[ -L "$dots_target" ]] && [[ "$(readlink "$dots_target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "  Unchanged: $dots_target → $SCRIPT_DIR/dotconfigs"
            else
                echo "  Would create: $dots_target → $SCRIPT_DIR/dotconfigs"
            fi
        else
            echo "CLI availability:"
            echo "  Would create: $target → $SCRIPT_DIR/dotconfigs"
            echo "  Would create: $(dirname "$target")/dots → $SCRIPT_DIR/dotconfigs"
        fi
        return 0
    fi

    # Create or verify both symlinks (dotconfigs + dots)
    local symlinks_to_check=("$target" "$(dirname "$target")/dots")
    local symlink_names=("dotconfigs" "dots")

    for i in 0 1; do
        local sym="${symlinks_to_check[$i]}"
        local name="${symlink_names[$i]}"

        if [[ -L "$sym" ]]; then
            local current=$(readlink "$sym")
            if [[ "$current" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "$name already on PATH (symlink correct)"
                continue
            else
                # Symlink exists but points elsewhere
                if [[ "$force_mode" != "true" ]]; then
                    echo "Warning: $name symlink exists but points to: $current" >&2
                    wizard_yesno "Overwrite with dotconfigs symlink?" "n" || continue
                fi
            fi
        elif [[ -e "$sym" ]]; then
            echo "Warning: File exists at $sym (not a symlink)" >&2
            continue
        fi

        # Create symlink
        if ln -sf "$SCRIPT_DIR/dotconfigs" "$sym" 2>/dev/null; then
            echo "$name added to PATH: $sym"
        else
            echo "Warning: Failed to create $name symlink at $sym" >&2
        fi
    done
}

cmd_deploy() {
    local group=""
    local dry_run=false
    local force_mode=false

    # Parse arguments: extract group name and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force_mode=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
            *)
                # First non-flag argument is the group name
                if [[ -z "$group" ]]; then
                    group="$1"
                fi
                shift
                ;;
        esac
    done

    # Initialize colours for dry-run header
    if [[ "$dry_run" == "true" ]]; then
        init_colours
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo "$(colour_cyan "  DRY RUN - No changes will be made")"
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo ""
    fi

    # Deploy from global.json
    deploy_from_json "$GLOBAL_CONFIG" "$SCRIPT_DIR" "$group" "$dry_run" "$force_mode"

    # Create PATH symlink (after all deploys)
    echo ""
    _create_path_symlink "$dry_run" "$force_mode"
}

cmd_status() {
    local plugin_filter="${1:-}"

    # Initialize colour codes
    init_colours

    # Check if .env exists
    if [[ ! -f "$ENV_FILE" ]]; then
        echo "Error: No configuration found. Run 'dotconfigs setup' then 'dotconfigs global-configs <plugin>' first." >&2
        exit 1
    fi

    # Iterate over all plugins
    while IFS= read -r plugin; do
        # Skip if filter provided and doesn't match
        if [[ -n "$plugin_filter" && "$plugin" != "$plugin_filter" ]]; then
            continue
        fi

        # Source the plugin's deploy.sh if not already sourced
        if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
            source "$PLUGINS_DIR/$plugin/deploy.sh"
        fi

        # Check if plugin_<name>_status function exists
        if declare -f "plugin_${plugin}_status" > /dev/null 2>&1; then
            "plugin_${plugin}_status"
        else
            printf "%b %s\n" "$(colour_red "$plugin")" "not configured"
        fi

        echo ""
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_list() {
    # Initialize colour codes
    init_colours

    # Source .env if it exists
    if [[ -f "$ENV_FILE" ]]; then
        source "$ENV_FILE"
    fi

    echo "Available plugins:"
    echo ""

    while IFS= read -r plugin; do
        local is_installed=false

        # Check if plugin is installed by looking for key env vars
        case "$plugin" in
            claude)
                if [[ -n "${CLAUDE_DEPLOY_TARGET:-}" ]]; then
                    is_installed=true
                fi
                ;;
            git)
                if [[ -n "${GIT_USER_NAME:-}" ]] || [[ -n "${GIT_USER_EMAIL:-}" ]]; then
                    is_installed=true
                fi
                ;;
            *)
                # Generic check: try to load plugin config
                if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
                    source "$PLUGINS_DIR/$plugin/deploy.sh"
                    if declare -f "_${plugin}_load_config" > /dev/null 2>&1; then
                        if "_${plugin}_load_config" > /dev/null 2>&1; then
                            is_installed=true
                        fi
                    fi
                fi
                ;;
        esac

        # Print with colour
        if [[ "$is_installed" == "true" ]]; then
            printf "  %b %s\n" "$(colour_green "$SYMBOL_OK")" "$plugin deployed"
        else
            printf "  %b %s\n" "$(colour_red "$SYMBOL_MISSING")" "$plugin not deployed"
        fi
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_project() {
    local project_path=""
    local dry_run="false"
    local force="false"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --force)
                force="true"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: dotconfigs project [path] [--dry-run] [--force]" >&2
                exit 1
                ;;
            *)
                if [[ -z "$project_path" ]]; then
                    project_path="$1"
                    shift
                else
                    echo "Error: Multiple paths specified" >&2
                    exit 1
                fi
                ;;
        esac
    done

    # Default to CWD if no path specified
    if [[ -z "$project_path" ]]; then
        project_path="$PWD"
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    # Check for project.json
    local config_file="$project_path/.dotconfigs/project.json"
    if [[ ! -f "$config_file" ]]; then
        echo "Error: No .dotconfigs/project.json found at $project_path" >&2
        echo "Run: dotconfigs project-init $project_path" >&2
        exit 1
    fi

    # Deploy from JSON
    deploy_from_json "$config_file" "$SCRIPT_DIR" "" "$dry_run" "$force" "$project_path"

    # Auto-exclude .dotconfigs/ in .git/info/exclude (unless dry-run)
    if [[ "$dry_run" != "true" ]]; then
        local exclude_file="$project_path/.git/info/exclude"
        if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
            mkdir -p "$(dirname "$exclude_file")"
            echo ".dotconfigs/" >> "$exclude_file"
            echo ""
            echo "Added .dotconfigs/ to .git/info/exclude"
        fi
    fi
}

cmd_project_init() {
    local project_path=""

    # Parse argument
    if [[ $# -eq 0 ]]; then
        # Check if CWD is the dotconfigs repo itself
        if [[ "$(pwd)" -ef "$SCRIPT_DIR" ]]; then
            echo "Error: Cannot use dotconfigs repo as project target" >&2
            echo "Run from a project directory, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Check if CWD is a git repo
        if ! git -C "$PWD" rev-parse --git-dir >/dev/null 2>&1; then
            echo "Error: Current directory is not a git repository" >&2
            echo "Run from a git repo, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Use CWD
        project_path="$PWD"
    else
        project_path="$1"
        shift
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    # Check if project.json already exists
    local config_file="$project_path/.dotconfigs/project.json"
    if [[ -f "$config_file" ]]; then
        echo "Project config already exists at $config_file"
        exit 0
    fi

    # Create .dotconfigs directory
    mkdir -p "$project_path/.dotconfigs"

    # Generate project.json dynamically from global.json
    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq" >&2
        exit 1
    fi

    # Use jq to transform global.json into project.json with project-specific overrides
    # Generate project.json from global.json (SSOT for include lists).
    # Only claude and git have project-level configs; vscode/shell are global-only.
    # Targets and methods are project-specific; include lists inherit from global.
    # Users customise per-project by adding items to "exclude".
    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq" >&2
        exit 1
    fi

    jq '{
      claude: {
        hooks: {
          source: .claude.hooks.source,
          target: ".claude/hooks",
          method: "symlink",
          include: .claude.hooks.include,
          exclude: []
        },
        settings: {
          source: "plugins/claude/templates/settings/project-template.json",
          target: ".claude/settings.json",
          method: "copy"
        }
      },
      git: {
        hooks: {
          source: .git.hooks.source,
          target: ".git/hooks",
          method: "symlink",
          include: .git.hooks.include,
          exclude: []
        },
        "exclude-patterns": {
          source: "plugins/git/project-exclude-patterns",
          target: ".git/info/exclude",
          method: "copy"
        },
        gitignore: {
          source: "plugins/git/templates/gitignore-default",
          target: ".gitignore",
          method: "copy"
        }
      }
    }' "$SCRIPT_DIR/global.json" > "$config_file"

    # Auto-exclude .dotconfigs/ in .git/info/exclude
    local exclude_file="$project_path/.git/info/exclude"
    if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
        mkdir -p "$(dirname "$exclude_file")"
        echo ".dotconfigs/" >> "$exclude_file"
    fi

    echo "Created .dotconfigs/project.json"
    echo "Added .dotconfigs/ to .git/info/exclude"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $config_file"
    echo "  2. Run: dotconfigs project          (from the project directory)"
}

main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    case "$1" in
        setup)
            # Check if plugin arg provided (legacy mode)
            if [[ $# -gt 1 ]]; then
                cmd_setup_legacy "${@:2}"
            else
                cmd_setup
            fi
            ;;
        global-configs)
            cmd_global_configs "${@:2}"
            ;;
        project-configs|project-init)
            cmd_project_init "${@:2}"
            ;;
        project)
            # Support "project init" as alias for "project-init"
            if [[ "${2:-}" == "init" ]]; then
                cmd_project_init "${@:3}"
            else
                cmd_project "${@:2}"
            fi
            ;;
        deploy)
            cmd_deploy "${@:2}"
            ;;
        status)
            cmd_status "${@:2}"
            ;;
        list)
            cmd_list
            ;;
        help)
            cmd_help "${@:2}"
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            echo "" >&2
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
