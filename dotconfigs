#!/bin/bash
# dotconfigs — Unified configuration management CLI entry point

set -e

# Resolve symlinks to find real script location (bash 3.2 compatible)
_source="${BASH_SOURCE[0]}"
while [[ -L "$_source" ]]; do
    _dir="$(cd "$(dirname "$_source")" && pwd)"
    _source="$(readlink "$_source")"
    [[ "$_source" != /* ]] && _source="$_dir/$_source"
done
SCRIPT_DIR="$(cd "$(dirname "$_source")" && pwd)"
unset _source _dir
PLUGINS_DIR="$SCRIPT_DIR/plugins"
ENV_FILE="$SCRIPT_DIR/.env"
GLOBAL_CONFIG="$SCRIPT_DIR/global.json"

# Source shared libraries eagerly (small files)
source "$SCRIPT_DIR/lib/wizard.sh"
source "$SCRIPT_DIR/lib/symlinks.sh"
source "$SCRIPT_DIR/lib/discovery.sh"
source "$SCRIPT_DIR/lib/validation.sh"
source "$SCRIPT_DIR/lib/colours.sh"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/deploy.sh"
source "$SCRIPT_DIR/lib/init.sh"

show_usage() {
    cat <<EOF
dotconfigs — Unified configuration management

Usage:
  dotconfigs setup                              One-time init (PATH + global.json)
  dotconfigs deploy [group] [options]           Deploy global config to filesystem
  dotconfigs project-init [path]                Scaffold per-project config
  dotconfigs project [path] [options]           Deploy per-project configuration
  dotconfigs global-configs <plugin>            Configure plugin via wizard (.env)
  dotconfigs status [plugin]                    Show deployment status
  dotconfigs list                               List available plugins
  dotconfigs help [command]                     Show help for command

Commands:
  setup           One-time init: scaffold global.json from manifests, add to PATH
  deploy          Deploy configuration from global.json (symlinks)
                  Options: --force, --dry-run
                  Without group: deploys all groups
                  Aliases: global-deploy
  project-init    Scaffold .dotconfigs/project.json from plugin manifests
                  Aliases: project-configs, project init
  project         Deploy per-project config from .dotconfigs/project.json
                  Options: --force, --dry-run
                  Aliases: project-deploy
  global-configs  Interactive wizard to configure plugin defaults (.env)
  status          Check deployment status (requires .env)
  list            List all available plugins
  help            Show detailed help for specific command

Examples:
  dotconfigs setup                      One-time init
  dotconfigs deploy                     Deploy all global config
  dotconfigs deploy claude              Deploy claude group only
  dotconfigs deploy --dry-run           Preview all deployments
  dotconfigs project-init .             Scaffold project config
  dotconfigs project .                  Deploy project configuration
  dotconfigs project . --force          Deploy, skip conflict prompts
  dotconfigs global-configs claude      Configure Claude via wizard

Available plugins:
EOF
    while IFS= read -r plugin; do
        echo "  - $plugin"
    done < <(discover_plugins "$PLUGINS_DIR")
}

show_command_help() {
    local command="$1"

    case "$command" in
        setup)
            cat <<EOF
dotconfigs setup — One-time initialisation

Usage:
  dotconfigs setup

Description:
  Scaffolds global.json from plugin manifests (if it doesn't exist).
  Creates PATH symlinks for dotconfigs and dots.
  Run once after cloning, then use 'dotconfigs deploy' to apply.

Example:
  dotconfigs setup
EOF
            ;;
        global-configs)
            cat <<EOF
dotconfigs global-configs — Configure plugin defaults

Usage:
  dotconfigs global-configs <plugin>

Description:
  Runs the interactive setup wizard for the specified plugin.
  Creates or updates .env file with plugin configuration.
  These are global defaults applied across all projects.

Available plugins:
EOF
            while IFS= read -r plugin; do
                echo "  - $plugin"
            done < <(discover_plugins "$PLUGINS_DIR")
            cat <<EOF

Examples:
  dotconfigs global-configs claude    Configure Claude Code settings
  dotconfigs global-configs git       Configure git hooks and identity
EOF
            ;;
        project-configs|project-init)
            cat <<EOF
dotconfigs project-init — Scaffold per-project configuration

Usage:
  dotconfigs project-init [path]

Aliases:
  dotconfigs project-configs [path]
  dotconfigs project init [path]

Description:
  Assembles .dotconfigs/project.json from plugin manifests (.project sections).
  Pre-populates include lists, empty exclude lists for customisation.
  Auto-excludes .dotconfigs/ in .git/info/exclude.
  Defaults to current directory if no path given.
  Requires a git repository.

  After creating the config, edit exclude lists, then run: dotconfigs project <path>

Examples:
  dotconfigs project-init .              Current directory
  dotconfigs project-init ~/myrepo       Specific project
  dotconfigs project init ~/myrepo       Space-separated alias
EOF
            ;;
        project)
            cat <<EOF
dotconfigs project — Deploy per-project configuration

Usage:
  dotconfigs project [path] [--dry-run] [--force]

Aliases:
  dotconfigs project-deploy [path] [options]

Description:
  Reads .dotconfigs/project.json and deploys all configured modules
  (hooks, skills, etc.) as symlinks into the project.
  Respects include/exclude lists per module.
  Defaults to current directory if no path given.
  Requires a git repository with .dotconfigs/project.json.

Options:
  --dry-run       Preview changes without deploying
  --force         Overwrite all conflicts without prompting

Examples:
  dotconfigs project .                   Deploy current project
  dotconfigs project ~/myrepo --force    Deploy, skip conflict prompts
  dotconfigs project . --dry-run         Preview deployment
EOF
            ;;
        deploy)
            cat <<EOF
dotconfigs deploy — Deploy global configuration

Usage:
  dotconfigs deploy [group] [options]

Aliases:
  dotconfigs global-deploy [group] [options]

Description:
  Deploys configuration from global.json to the filesystem via symlinks.
  Without a group name, deploys all groups.
  Also ensures dotconfigs and dots are on PATH.

Options:
  --force          Overwrite all conflicts without prompting
  --dry-run        Preview changes without deploying

Conflicts (files not managed by dotconfigs) prompt for resolution:
overwrite, skip, backup, or diff. Use --force to skip prompts.

Examples:
  dotconfigs deploy                      Deploy all groups
  dotconfigs deploy claude               Deploy claude group only
  dotconfigs deploy git                  Deploy git group only
  dotconfigs deploy --force              Deploy all, overwrite conflicts
  dotconfigs deploy --dry-run            Preview all deployments
EOF
            ;;
        status)
            cat <<EOF
dotconfigs status — Check deployment status

Usage:
  dotconfigs status [plugin]

Description:
  Shows deployment status for plugin configuration files.
  Detects drift (broken symlinks, foreign files, wrong targets).
  Without a plugin name, shows status for all plugins.

States:
  ✓  Deployed      Symlink correctly points to dotconfigs
  △  Drifted       Broken symlink, foreign file, or wrong target
  ✗  Not deployed  File doesn't exist

Examples:
  dotconfigs status           Show status of all plugins
  dotconfigs status claude    Show Claude plugin status only
EOF
            ;;
        list)
            cat <<EOF
dotconfigs list — List available plugins

Usage:
  dotconfigs list

Description:
  Lists all available plugins with descriptions.

Example:
  dotconfigs list
EOF
            ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            echo "" >&2
            echo "Available commands: setup, deploy, project-init, project, global-configs, status, list, help" >&2
            return 1
            ;;
    esac
}

cmd_help() {
    if [[ $# -eq 0 ]]; then
        show_usage
    else
        show_command_help "$1"
    fi
}

cmd_setup_legacy() {
    echo "Warning: 'dotconfigs setup <plugin>' is deprecated." >&2
    echo "Use: 'dotconfigs global-configs $1' instead." >&2
    return 1
}

cmd_setup() {
    init_colours

    echo ""
    echo "========================================================="
    echo "  dotconfigs - First Time Setup"
    echo "========================================================="
    echo ""

    # Scaffold global.json from manifests if it doesn't exist
    if [[ ! -f "$GLOBAL_CONFIG" ]]; then
        if command -v jq &>/dev/null; then
            assemble_from_manifests "global" > "$GLOBAL_CONFIG"
            echo "Created global.json from plugin manifests"
        else
            echo "Warning: jq not installed, skipping global.json scaffold" >&2
        fi
    fi

    # Save version marker
    wizard_save_env "$ENV_FILE" "DOTCONFIGS_VERSION" "2.0"

    # Create PATH symlinks (dotconfigs + dots)
    echo "Setting up PATH availability..."
    _create_path_symlink "false" "false"

    echo ""
    echo "Setup complete."
    echo ""
    echo "Next steps — configure your plugins:"
    while IFS= read -r p; do
        echo "  dotconfigs global-configs $p"
    done < <(discover_plugins "$PLUGINS_DIR")
    echo ""
    echo "Then deploy with: dotconfigs deploy"
    echo ""
}

cmd_global_configs() {
    local plugin=$1

    if [[ -z "$plugin" ]]; then
        echo "Error: Plugin name required" >&2
        echo "Usage: dotconfigs global-configs <plugin>" >&2
        echo "" >&2
        list_available_plugins
        exit 1
    fi

    if ! plugin_exists "$plugin"; then
        echo "Error: Plugin '$plugin' not found" >&2
        list_available_plugins
        exit 1
    fi

    # Load and run plugin wizard
    source "$PLUGINS_DIR/$plugin/setup.sh"
    "plugin_${plugin}_setup" "$@"
}

_create_path_symlink() {
    local dry_run="$1"
    local force_mode="$2"

    # Determine symlink target: prefer ~/.local/bin, fall back to /usr/local/bin
    local target=""
    if [[ -d "$HOME/.local/bin" ]]; then
        target="$HOME/.local/bin/dotconfigs"
    elif [[ -d "/usr/local/bin" ]]; then
        target="/usr/local/bin/dotconfigs"
    else
        # Neither exists, try to create ~/.local/bin
        if mkdir -p "$HOME/.local/bin" 2>/dev/null; then
            target="$HOME/.local/bin/dotconfigs"
        else
            echo "Warning: Cannot create ~/.local/bin and /usr/local/bin not found" >&2
            echo "To make dotconfigs available on PATH, add to your shell profile:" >&2
            echo "  export PATH=\"$SCRIPT_DIR:\$PATH\"" >&2
            return 0
        fi
    fi

    # Dry-run mode
    if [[ "$dry_run" == "true" ]]; then
        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
            echo "CLI availability:"
            echo "  Unchanged: $target → $SCRIPT_DIR/dotconfigs"
            local dots_target="$(dirname "$target")/dots"
            if [[ -L "$dots_target" ]] && [[ "$(readlink "$dots_target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "  Unchanged: $dots_target → $SCRIPT_DIR/dotconfigs"
            else
                echo "  Would create: $dots_target → $SCRIPT_DIR/dotconfigs"
            fi
        else
            echo "CLI availability:"
            echo "  Would create: $target → $SCRIPT_DIR/dotconfigs"
            echo "  Would create: $(dirname "$target")/dots → $SCRIPT_DIR/dotconfigs"
        fi
        return 0
    fi

    # Create or verify both symlinks (dotconfigs + dots)
    local symlinks_to_check=("$target" "$(dirname "$target")/dots")
    local symlink_names=("dotconfigs" "dots")

    for i in 0 1; do
        local sym="${symlinks_to_check[$i]}"
        local name="${symlink_names[$i]}"

        if [[ -L "$sym" ]]; then
            local current=$(readlink "$sym")
            if [[ "$current" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "$name already on PATH (symlink correct)"
                continue
            else
                # Symlink exists but points elsewhere
                if [[ "$force_mode" != "true" ]]; then
                    echo "Warning: $name symlink exists but points to: $current" >&2
                    wizard_yesno "Overwrite with dotconfigs symlink?" "n" || continue
                fi
            fi
        elif [[ -e "$sym" ]]; then
            echo "Warning: File exists at $sym (not a symlink)" >&2
            continue
        fi

        # Create symlink
        if ln -sf "$SCRIPT_DIR/dotconfigs" "$sym" 2>/dev/null; then
            echo "$name added to PATH: $sym"
        else
            echo "Warning: Failed to create $name symlink at $sym" >&2
        fi
    done
}

cmd_deploy() {
    local group=""
    local dry_run=false
    local force_mode=false

    # Parse arguments: extract group name and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force_mode=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
            *)
                # First non-flag argument is the group name
                if [[ -z "$group" ]]; then
                    group="$1"
                fi
                shift
                ;;
        esac
    done

    # Initialize colours for dry-run header
    if [[ "$dry_run" == "true" ]]; then
        init_colours
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo "$(colour_cyan "  DRY RUN - No changes will be made")"
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo ""
    fi

    # Deploy from global.json
    deploy_from_json "$GLOBAL_CONFIG" "$SCRIPT_DIR" "$group" "$dry_run" "$force_mode"

    # Create PATH symlink (after all deploys)
    echo ""
    _create_path_symlink "$dry_run" "$force_mode"
}

cmd_status() {
    local plugin_filter="${1:-}"

    # Initialize colour codes
    init_colours

    # Check if .env exists
    if [[ ! -f "$ENV_FILE" ]]; then
        echo "Error: No configuration found. Run 'dotconfigs setup' then 'dotconfigs global-configs <plugin>' first." >&2
        exit 1
    fi

    # Iterate over all plugins
    while IFS= read -r plugin; do
        # Skip if filter provided and doesn't match
        if [[ -n "$plugin_filter" && "$plugin" != "$plugin_filter" ]]; then
            continue
        fi

        # Source the plugin's deploy.sh if not already sourced
        if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
            source "$PLUGINS_DIR/$plugin/deploy.sh"
        fi

        # Check if plugin_<name>_status function exists
        if declare -f "plugin_${plugin}_status" > /dev/null 2>&1; then
            "plugin_${plugin}_status"
        else
            printf "%b %s\n" "$(colour_red "$plugin")" "not configured"
        fi

        echo ""
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_list() {
    # Initialize colour codes
    init_colours

    # Source .env if it exists
    if [[ -f "$ENV_FILE" ]]; then
        source "$ENV_FILE"
    fi

    echo "Available plugins:"
    echo ""

    while IFS= read -r plugin; do
        local is_installed=false

        # Check if plugin is installed by looking for key env vars
        case "$plugin" in
            claude)
                if [[ -n "${CLAUDE_DEPLOY_TARGET:-}" ]]; then
                    is_installed=true
                fi
                ;;
            git)
                if [[ -n "${GIT_USER_NAME:-}" ]] || [[ -n "${GIT_USER_EMAIL:-}" ]]; then
                    is_installed=true
                fi
                ;;
            *)
                # Generic check: try to load plugin config
                if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
                    source "$PLUGINS_DIR/$plugin/deploy.sh"
                    if declare -f "_${plugin}_load_config" > /dev/null 2>&1; then
                        if "_${plugin}_load_config" > /dev/null 2>&1; then
                            is_installed=true
                        fi
                    fi
                fi
                ;;
        esac

        # Print with colour
        if [[ "$is_installed" == "true" ]]; then
            printf "  %b %s\n" "$(colour_green "$SYMBOL_OK")" "$plugin deployed"
        else
            printf "  %b %s\n" "$(colour_red "$SYMBOL_MISSING")" "$plugin not deployed"
        fi
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_project() {
    local project_path=""
    local dry_run="false"
    local force="false"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --force)
                force="true"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: dotconfigs project [path] [--dry-run] [--force]" >&2
                exit 1
                ;;
            *)
                if [[ -z "$project_path" ]]; then
                    project_path="$1"
                    shift
                else
                    echo "Error: Multiple paths specified" >&2
                    exit 1
                fi
                ;;
        esac
    done

    # Default to CWD if no path specified
    if [[ -z "$project_path" ]]; then
        project_path="$PWD"
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    # Check for project.json
    local config_file="$project_path/.dotconfigs/project.json"
    if [[ ! -f "$config_file" ]]; then
        echo "Error: No .dotconfigs/project.json found at $project_path" >&2
        echo "Run: dotconfigs project-init $project_path" >&2
        exit 1
    fi

    # Deploy from JSON
    deploy_from_json "$config_file" "$SCRIPT_DIR" "" "$dry_run" "$force" "$project_path"

    # Auto-exclude .dotconfigs/ in .git/info/exclude (unless dry-run)
    if [[ "$dry_run" != "true" ]]; then
        local exclude_file="$project_path/.git/info/exclude"
        if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
            mkdir -p "$(dirname "$exclude_file")"
            echo ".dotconfigs/" >> "$exclude_file"
            echo ""
            echo "Added .dotconfigs/ to .git/info/exclude"
        fi
    fi
}

cmd_project_init() {
    local project_path=""

    # Parse argument
    if [[ $# -eq 0 ]]; then
        # Check if CWD is the dotconfigs repo itself
        if [[ "$(pwd)" -ef "$SCRIPT_DIR" ]]; then
            echo "Error: Cannot use dotconfigs repo as project target" >&2
            echo "Run from a project directory, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Check if CWD is a git repo
        if ! git -C "$PWD" rev-parse --git-dir >/dev/null 2>&1; then
            echo "Error: Current directory is not a git repository" >&2
            echo "Run from a git repo, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Use CWD
        project_path="$PWD"
    else
        project_path="$1"
        shift
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq" >&2
        exit 1
    fi

    local config_file="$project_path/.dotconfigs/project.json"
    local json
    json=$(assemble_from_manifests "project")

    if ! write_with_overwrite_protection "$config_file" "$json"; then
        return 0
    fi

    # Auto-exclude .dotconfigs/ in .git/info/exclude
    local exclude_file="$project_path/.git/info/exclude"
    if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
        mkdir -p "$(dirname "$exclude_file")"
        echo ".dotconfigs/" >> "$exclude_file"
        echo "Added .dotconfigs/ to .git/info/exclude"
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Edit $config_file"
    echo "  2. Run: dotconfigs project          (from the project directory)"
}

main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    case "$1" in
        setup)
            # Check if plugin arg provided (legacy mode)
            if [[ $# -gt 1 ]]; then
                cmd_setup_legacy "${@:2}"
            else
                cmd_setup
            fi
            ;;
        global-configs)
            cmd_global_configs "${@:2}"
            ;;
        project-configs|project-init)
            cmd_project_init "${@:2}"
            ;;
        project|project-deploy)
            # Support "project init" as alias for "project-init"
            if [[ "${2:-}" == "init" ]]; then
                cmd_project_init "${@:3}"
            else
                cmd_project "${@:2}"
            fi
            ;;
        deploy|global-deploy)
            cmd_deploy "${@:2}"
            ;;
        status)
            cmd_status "${@:2}"
            ;;
        list)
            cmd_list
            ;;
        help)
            cmd_help "${@:2}"
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            echo "" >&2
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
