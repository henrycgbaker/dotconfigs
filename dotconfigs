#!/bin/bash
# dotconfigs — Unified configuration management CLI entry point

set -e

# Resolve symlinks to find real script location (bash 3.2 compatible)
_source="${BASH_SOURCE[0]}"
while [[ -L "$_source" ]]; do
    _dir="$(cd "$(dirname "$_source")" && pwd)"
    _source="$(readlink "$_source")"
    [[ "$_source" != /* ]] && _source="$_dir/$_source"
done
SCRIPT_DIR="$(cd "$(dirname "$_source")" && pwd)"
unset _source _dir
PLUGINS_DIR="$SCRIPT_DIR/plugins"
ENV_FILE="$SCRIPT_DIR/.env"

# Source shared libraries eagerly (small files)
source "$SCRIPT_DIR/lib/wizard.sh"
source "$SCRIPT_DIR/lib/symlinks.sh"
source "$SCRIPT_DIR/lib/discovery.sh"
source "$SCRIPT_DIR/lib/validation.sh"
source "$SCRIPT_DIR/lib/colours.sh"
source "$SCRIPT_DIR/lib/config.sh"

show_usage() {
    cat <<EOF
dotconfigs — Unified configuration management

Usage:
  dotconfigs setup                              Initialize tool (PATH symlinks)
  dotconfigs global-configs <plugin>            Configure plugin defaults (.env)
  dotconfigs project-configs [plugin] <path>    Configure per-project overrides
  dotconfigs deploy [plugin] [options]          Deploy configuration to filesystem
  dotconfigs status [plugin]                    Show deployment status
  dotconfigs list                               List available plugins
  dotconfigs help [command]                     Show help for command
  dotconfigs --help                             Show this help

Commands:
  setup           Initialize dotconfigs tool (one-time setup)
  global-configs  Interactive wizard to configure plugin defaults (.env)
  project-configs Scaffold per-project configuration overrides
  deploy          Deploy configuration from .env to filesystem
                  Options: --force, --dry-run
                  Without plugin: deploys all configured plugins
  status          Check deployment status and drift detection
  list            List all available plugins
  help            Show detailed help for specific command

Examples:
  dotconfigs setup                      Initialize dotconfigs
  dotconfigs global-configs claude      Configure Claude defaults
  dotconfigs project-configs claude .   Override Claude config for project
  dotconfigs deploy                     Deploy all configurations
  dotconfigs deploy git                 Deploy git configuration only
  dotconfigs deploy --dry-run           Preview all deployments
  dotconfigs status                     Show status of all plugins
  dotconfigs list                       Show all plugins

Available plugins:
EOF
    while IFS= read -r plugin; do
        echo "  - $plugin"
    done < <(discover_plugins "$PLUGINS_DIR")
}

show_command_help() {
    local command="$1"

    case "$command" in
        setup)
            cat <<EOF
dotconfigs setup — Initialize dotconfigs tool

Usage:
  dotconfigs setup

Description:
  One-time initialization of dotconfigs.
  Configures deploy target directory and adds tool to PATH.
  Run this once before configuring individual plugins.

Example:
  dotconfigs setup    Initialize dotconfigs
EOF
            ;;
        global-configs)
            cat <<EOF
dotconfigs global-configs — Configure plugin defaults

Usage:
  dotconfigs global-configs <plugin>

Description:
  Runs the interactive setup wizard for the specified plugin.
  Creates or updates .env file with plugin configuration.
  These are global defaults applied across all projects.

Available plugins:
EOF
            while IFS= read -r plugin; do
                echo "  - $plugin"
            done < <(discover_plugins "$PLUGINS_DIR")
            cat <<EOF

Examples:
  dotconfigs global-configs claude    Configure Claude Code settings
  dotconfigs global-configs git       Configure git hooks and identity
EOF
            ;;
        project-configs)
            cat <<EOF
dotconfigs project-configs — Scaffold per-project configuration

Usage:
  dotconfigs project-configs [plugin] <path>

Description:
  Scaffolds per-project configuration files for the specified plugin.
  These override global defaults from .env for specific projects.
  Without a plugin name, runs project setup for all plugins.
  Requires a git repository at the target path.

Examples:
  dotconfigs project-configs .              Run all plugin project setup
  dotconfigs project-configs claude .       Run Claude project setup only
  dotconfigs project-configs git /path      Configure git for specific repo
EOF
            ;;
        project)
            echo "Warning: 'dotconfigs project' is deprecated. Use 'dotconfigs project-configs' instead." >&2
            echo "" >&2
            show_command_help "project-configs"
            ;;
        deploy)
            cat <<EOF
dotconfigs deploy — Deploy configuration to filesystem

Usage:
  dotconfigs deploy [plugin] [options]

Description:
  Deploys plugin configuration from .env to the filesystem.
  Without a plugin name, deploys all configured plugins.

Options:
  --force          Overwrite all conflicts without prompting
  --dry-run        Preview changes without deploying

Conflicts (files not managed by dotconfigs) prompt for resolution:
overwrite, skip, backup, or diff. Use --force to skip prompts.

Examples:
  dotconfigs deploy                      Deploy all (prompts on conflicts)
  dotconfigs deploy claude               Deploy Claude configuration only
  dotconfigs deploy --force              Deploy all, overwrite conflicts
  dotconfigs deploy --dry-run            Preview all deployments
EOF
            ;;
        status)
            cat <<EOF
dotconfigs status — Check deployment status

Usage:
  dotconfigs status [plugin]

Description:
  Shows deployment status for plugin configuration files.
  Detects drift (broken symlinks, foreign files, wrong targets).
  Without a plugin name, shows status for all plugins.

States:
  ✓  Deployed      Symlink correctly points to dotconfigs
  △  Drifted       Broken symlink, foreign file, or wrong target
  ✗  Not deployed  File doesn't exist

Examples:
  dotconfigs status           Show status of all plugins
  dotconfigs status claude    Show Claude plugin status only
EOF
            ;;
        list)
            cat <<EOF
dotconfigs list — List available plugins

Usage:
  dotconfigs list

Description:
  Lists all available plugins with descriptions.

Example:
  dotconfigs list
EOF
            ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            echo "" >&2
            echo "Available commands: setup, global-configs, project-configs, deploy, status, list, help" >&2
            return 1
            ;;
    esac
}

cmd_help() {
    if [[ $# -eq 0 ]]; then
        show_usage
    else
        show_command_help "$1"
    fi
}

cmd_setup_legacy() {
    echo "Warning: 'dotconfigs setup <plugin>' is deprecated." >&2
    echo "Use: 'dotconfigs global-configs $1' instead." >&2
    return 1
}

cmd_setup() {
    init_colours

    echo ""
    echo "========================================================="
    echo "  dotconfigs - First Time Setup"
    echo "========================================================="
    echo ""

    # Save version marker
    wizard_save_env "$ENV_FILE" "DOTCONFIGS_VERSION" "2.0"

    # Create PATH symlinks (dotconfigs + dots)
    echo "Setting up PATH availability..."
    _create_path_symlink "false" "false"

    echo ""
    echo "Setup complete."
    echo ""
    echo "Next steps — configure your plugins:"
    while IFS= read -r p; do
        echo "  dotconfigs global-configs $p"
    done < <(discover_plugins "$PLUGINS_DIR")
    echo ""
    echo "Then deploy with: dotconfigs deploy"
    echo ""
}

cmd_global_configs() {
    local plugin=$1

    if [[ -z "$plugin" ]]; then
        echo "Error: Plugin name required" >&2
        echo "Usage: dotconfigs global-configs <plugin>" >&2
        echo "" >&2
        list_available_plugins
        exit 1
    fi

    if ! plugin_exists "$plugin"; then
        echo "Error: Plugin '$plugin' not found" >&2
        list_available_plugins
        exit 1
    fi

    # Load and run plugin wizard
    source "$PLUGINS_DIR/$plugin/setup.sh"
    "plugin_${plugin}_setup" "$@"
}

_create_path_symlink() {
    local dry_run="$1"
    local force_mode="$2"

    # Determine symlink target: prefer ~/.local/bin, fall back to /usr/local/bin
    local target=""
    if [[ -d "$HOME/.local/bin" ]]; then
        target="$HOME/.local/bin/dotconfigs"
    elif [[ -d "/usr/local/bin" ]]; then
        target="/usr/local/bin/dotconfigs"
    else
        # Neither exists, try to create ~/.local/bin
        if mkdir -p "$HOME/.local/bin" 2>/dev/null; then
            target="$HOME/.local/bin/dotconfigs"
        else
            echo "Warning: Cannot create ~/.local/bin and /usr/local/bin not found" >&2
            echo "To make dotconfigs available on PATH, add to your shell profile:" >&2
            echo "  export PATH=\"$SCRIPT_DIR:\$PATH\"" >&2
            return 0
        fi
    fi

    # Dry-run mode
    if [[ "$dry_run" == "true" ]]; then
        echo "Would create symlink: $target -> $SCRIPT_DIR/dotconfigs"
        return 0
    fi

    # Check if symlink already exists and is correct
    if [[ -L "$target" ]]; then
        local current_target=$(readlink "$target")
        if [[ "$current_target" == "$SCRIPT_DIR/dotconfigs" ]]; then
            echo "dotconfigs already on PATH (symlink correct)"
            return 0
        else
            # Symlink exists but points elsewhere
            if [[ "$force_mode" != "true" ]]; then
                echo "Warning: Symlink exists but points to: $current_target" >&2
                wizard_yesno "Overwrite with dotconfigs symlink?" "n" || return 0
            fi
        fi
    elif [[ -e "$target" ]]; then
        # Regular file exists
        echo "Warning: File exists at $target (not a symlink)" >&2
        echo "Manual action required: remove or rename the file, then re-run deploy" >&2
        return 0
    fi

    # Create symlink
    if ln -sf "$SCRIPT_DIR/dotconfigs" "$target" 2>/dev/null; then
        # Verify it's on PATH
        if command -v dotconfigs >/dev/null 2>&1; then
            echo "dotconfigs added to PATH: $target"
        else
            echo "Symlink created: $target" >&2
            echo "Note: $(dirname "$target") may not be on your PATH" >&2
            echo "Add to shell profile if needed: export PATH=\"$(dirname "$target"):\$PATH\"" >&2
        fi
    else
        echo "Warning: Failed to create symlink at $target (permission denied?)" >&2
        echo "To make dotconfigs available on PATH, add to your shell profile:" >&2
        echo "  export PATH=\"$SCRIPT_DIR:\$PATH\"" >&2
    fi

    # Also create/verify dots alias symlink
    local dots_target="$(dirname "$target")/dots"
    if [[ -L "$dots_target" ]]; then
        local dots_current=$(readlink "$dots_target")
        if [[ "$dots_current" == "$SCRIPT_DIR/dotconfigs" ]]; then
            echo "dots already on PATH (symlink correct)"
        else
            ln -sf "$SCRIPT_DIR/dotconfigs" "$dots_target" 2>/dev/null && \
                echo "dots alias updated on PATH: $dots_target" || true
        fi
    elif [[ ! -e "$dots_target" ]]; then
        ln -sf "$SCRIPT_DIR/dotconfigs" "$dots_target" 2>/dev/null && \
            echo "dots alias added to PATH: $dots_target" || true
    fi
}

cmd_deploy() {
    local plugin=""
    local dry_run=false
    local force_mode=false
    local interactive_mode=true
    local args=()

    # Parse arguments: extract plugin name and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force_mode=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
            *)
                # First non-flag argument is the plugin name
                if [[ -z "$plugin" ]]; then
                    plugin="$1"
                fi
                shift
                ;;
        esac
    done

    # Build args array to pass to plugin deploy functions
    if [[ "$dry_run" == "true" ]]; then
        args+=("--dry-run")
        # Initialize colours for dry-run header
        init_colours
    fi

    # Flag precedence: --dry-run overrides --force
    if [[ "$dry_run" != "true" && "$force_mode" == "true" ]]; then
        args+=("--force")
    fi

    if [[ "$interactive_mode" == "true" ]]; then
        args+=("--interactive")
    fi

    if [[ -z "$plugin" ]]; then
        # Deploy all configured plugins
        if [[ "$dry_run" == "true" ]]; then
            echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
            echo "$(colour_cyan "  DRY RUN - No changes will be made")"
            echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
            echo ""
        fi
        echo "Deploying all configured plugins..."
        local deployed_any=false
        while IFS= read -r p; do
            if [[ -f "$PLUGINS_DIR/$p/deploy.sh" ]]; then
                echo ""
                echo "==> Deploying $p"
                source "$PLUGINS_DIR/$p/deploy.sh"
                "plugin_${p}_deploy" "${args[@]}"
                deployed_any=true
            fi
        done < <(discover_plugins "$PLUGINS_DIR")

        if [[ "$deployed_any" == "false" ]]; then
            echo "No plugins with deploy support found" >&2
            exit 1
        fi
    else
        # Deploy single plugin
        if ! plugin_exists "$plugin"; then
            echo "Error: Plugin '$plugin' not found" >&2
            echo "" >&2
            list_available_plugins
            exit 1
        fi

        if [[ "$dry_run" == "true" ]]; then
            echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
            echo "$(colour_cyan "  DRY RUN - No changes will be made")"
            echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
            echo ""
        fi

        source "$PLUGINS_DIR/$plugin/deploy.sh"
        "plugin_${plugin}_deploy" "${args[@]}"
    fi

    # Create PATH symlink (after all plugin deploys)
    echo ""
    echo "CLI availability:"
    _create_path_symlink "$dry_run" "$force_mode"
}

cmd_status() {
    local plugin_filter="${1:-}"

    # Initialize colour codes
    init_colours

    # Check if .env exists
    if [[ ! -f "$ENV_FILE" ]]; then
        echo "Error: No configuration found. Run 'dotconfigs setup' then 'dotconfigs global-configs <plugin>' first." >&2
        exit 1
    fi

    # Iterate over all plugins
    while IFS= read -r plugin; do
        # Skip if filter provided and doesn't match
        if [[ -n "$plugin_filter" && "$plugin" != "$plugin_filter" ]]; then
            continue
        fi

        # Source the plugin's deploy.sh if not already sourced
        if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
            source "$PLUGINS_DIR/$plugin/deploy.sh"
        fi

        # Check if plugin_<name>_status function exists
        if declare -f "plugin_${plugin}_status" > /dev/null 2>&1; then
            "plugin_${plugin}_status"
        else
            printf "%b %s\n" "$(colour_red "$plugin")" "not configured"
        fi

        echo ""
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_list() {
    # Initialize colour codes
    init_colours

    # Source .env if it exists
    if [[ -f "$ENV_FILE" ]]; then
        source "$ENV_FILE"
    fi

    echo "Available plugins:"
    echo ""

    while IFS= read -r plugin; do
        local is_installed=false

        # Check if plugin is installed by looking for key env vars
        case "$plugin" in
            claude)
                if [[ -n "${CLAUDE_DEPLOY_TARGET:-}" ]]; then
                    is_installed=true
                fi
                ;;
            git)
                if [[ -n "${GIT_USER_NAME:-}" ]] || [[ -n "${GIT_USER_EMAIL:-}" ]]; then
                    is_installed=true
                fi
                ;;
            *)
                # Generic check: try to load plugin config
                if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
                    source "$PLUGINS_DIR/$plugin/deploy.sh"
                    if declare -f "_${plugin}_load_config" > /dev/null 2>&1; then
                        if "_${plugin}_load_config" > /dev/null 2>&1; then
                            is_installed=true
                        fi
                    fi
                fi
                ;;
        esac

        # Print with colour
        if [[ "$is_installed" == "true" ]]; then
            printf "  %b %s\n" "$(colour_green "$SYMBOL_OK")" "$plugin deployed"
        else
            printf "  %b %s\n" "$(colour_red "$SYMBOL_MISSING")" "$plugin not deployed"
        fi
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_project_configs() {
    local plugin_filter=""
    local project_path=""

    # Parse arguments: could be "project-configs ." or "project-configs claude ."
    # If first arg is a plugin name, treat it as filter
    if [[ $# -gt 0 ]] && plugin_exists "$1"; then
        plugin_filter="$1"
        shift
    fi

    # If no path argument, try CWD detection
    if [[ $# -eq 0 ]]; then
        # Check if CWD is the dotconfigs repo itself
        if [[ "$(pwd)" -ef "$SCRIPT_DIR" ]]; then
            echo "Error: Cannot use dotconfigs repo as project target" >&2
            echo "Specify a path: dotconfigs project-configs <path>" >&2
            exit 1
        fi

        # Check if CWD is a git repo
        if ! git -C "$PWD" rev-parse --git-dir >/dev/null 2>&1; then
            echo "Error: Current directory is not a git repository" >&2
            echo "Either run from a git repo or specify path: dotconfigs project-configs <path>" >&2
            exit 1
        fi

        # Confirm with user
        echo "Detected project: $(basename "$PWD") ($PWD)"
        if wizard_yesno "Use this directory?" "y"; then
            project_path="$PWD"
        else
            echo "Specify path: dotconfigs project-configs <path>" >&2
            exit 1
        fi
    else
        project_path="$1"
        shift
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    # Execute project setup
    if [[ -n "$plugin_filter" ]]; then
        # Single plugin mode
        if [[ ! -f "$PLUGINS_DIR/$plugin_filter/project.sh" ]]; then
            echo "Error: Plugin '$plugin_filter' does not support project setup" >&2
            exit 1
        fi

        source "$PLUGINS_DIR/$plugin_filter/project.sh"
        "plugin_${plugin_filter}_project" "$project_path"
    else
        # All plugins mode
        local ran_any=false
        while IFS= read -r plugin; do
            if [[ -f "$PLUGINS_DIR/$plugin/project.sh" ]]; then
                source "$PLUGINS_DIR/$plugin/project.sh"
                "plugin_${plugin}_project" "$project_path"
                ran_any=true
            fi
        done < <(discover_plugins "$PLUGINS_DIR")

        if [[ "$ran_any" == "false" ]]; then
            echo "No plugins with project setup found" >&2
            exit 1
        fi
    fi
}

main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    case "$1" in
        setup)
            # Check if plugin arg provided (legacy mode)
            if [[ $# -gt 1 ]]; then
                cmd_setup_legacy "${@:2}"
            else
                cmd_setup
            fi
            ;;
        global-configs)
            cmd_global_configs "${@:2}"
            ;;
        project-configs)
            cmd_project_configs "${@:2}"
            ;;
        project)
            echo "Warning: 'dotconfigs project' is deprecated" >&2
            echo "Use: 'dotconfigs project-configs' instead" >&2
            echo "" >&2
            cmd_project_configs "${@:2}"
            ;;
        deploy)
            cmd_deploy "${@:2}"
            ;;
        status)
            cmd_status "${@:2}"
            ;;
        list)
            cmd_list
            ;;
        help)
            cmd_help "${@:2}"
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            echo "" >&2
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
