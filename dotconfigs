#!/bin/bash
# dotconfigs — Unified configuration management CLI entry point

set -e

# Resolve symlinks to find real script location (bash 3.2 compatible)
_source="${BASH_SOURCE[0]}"
while [[ -L "$_source" ]]; do
    _dir="$(cd "$(dirname "$_source")" && pwd)"
    _source="$(readlink "$_source")"
    [[ "$_source" != /* ]] && _source="$_dir/$_source"
done
SCRIPT_DIR="$(cd "$(dirname "$_source")" && pwd)"
unset _source _dir
PLUGINS_DIR="$SCRIPT_DIR/plugins"
ENV_FILE="$SCRIPT_DIR/.env"
GLOBAL_CONFIG="$SCRIPT_DIR/.dotconfigs/global.json"

# Source shared libraries eagerly (small files)
source "$SCRIPT_DIR/lib/wizard.sh"
source "$SCRIPT_DIR/lib/symlinks.sh"
source "$SCRIPT_DIR/lib/discovery.sh"
source "$SCRIPT_DIR/lib/validation.sh"
source "$SCRIPT_DIR/lib/colours.sh"
source "$SCRIPT_DIR/lib/deploy.sh"
source "$SCRIPT_DIR/lib/init.sh"

show_usage() {
    cat <<EOF
dotconfigs — Unified configuration management

Usage:
  dotconfigs setup                              One-time init (PATH symlinks)
  dotconfigs global-init                        Scaffold global.json from manifests
  dotconfigs global-deploy [group] [options]    Deploy global config to filesystem
  dotconfigs project-init [path]                Scaffold per-project config
  dotconfigs project-deploy [path] [options]    Deploy per-project configuration
  dotconfigs global-configs <plugin>            Configure plugin via wizard (.env)
  dotconfigs cleanup [options]                  Remove stale/broken symlinks
  dotconfigs status [plugin]                    Show deployment status
  dotconfigs list                               List available plugins
  dotconfigs help [command]                     Show help for command

Commands:
  setup           One-time init: add dotconfigs to PATH, then run global-init
  global-init     Scaffold global.json from plugin manifests
  global-deploy   Deploy configuration from global.json (symlinks)
                  Options: --force, --dry-run
                  Without group: deploys all groups
                  Aliases: deploy
  project-init    Scaffold .dotconfigs/project.json from plugin manifests
  project-deploy  Deploy per-project config from .dotconfigs/project.json
                  Options: --force, --dry-run
                  Aliases: project
  cleanup         Remove stale dotconfigs symlinks and broken symlinks
                  Default: dry-run. Use --apply to actually remove.
                  Options: --apply, --dry-run, --project <path>
  global-configs  Interactive wizard to configure plugin defaults (.env)
  status          Check deployment status (requires .env)
  list            List all available plugins
  help            Show detailed help for specific command

Examples:
  dotconfigs setup                      One-time init (PATH only)
  dotconfigs global-init                Scaffold global.json
  dotconfigs global-deploy              Deploy all global config
  dotconfigs global-deploy claude       Deploy claude group only
  dotconfigs global-deploy --dry-run    Preview all deployments
  dotconfigs project-init .             Scaffold project config
  dotconfigs project-deploy .           Deploy project configuration
  dotconfigs project-deploy . --force   Deploy, skip conflict prompts
  dotconfigs global-configs claude      Configure Claude via wizard

Available plugins:
EOF
    while IFS= read -r plugin; do
        echo "  - $plugin"
    done < <(discover_plugins "$PLUGINS_DIR")
}

show_command_help() {
    local command="$1"

    case "$command" in
        setup)
            cat <<EOF
dotconfigs setup — One-time initialisation

Usage:
  dotconfigs setup

Description:
  Creates PATH symlinks for dotconfigs and dots.
  Run once after cloning, then run 'global-init' to scaffold config.

Example:
  dotconfigs setup
EOF
            ;;
        global-init)
            cat <<EOF
dotconfigs global-init — Scaffold global.json

Usage:
  dotconfigs global-init

Description:
  Assembles global.json from plugin manifests (.global sections).
  Pre-populates modules with sources, targets, and include/exclude lists.
  Won't overwrite an existing global.json without confirmation.

  After creating the config, edit it to customise, then run: dotconfigs deploy

Example:
  dotconfigs global-init
EOF
            ;;
        global-configs)
            cat <<EOF
dotconfigs global-configs — Configure plugin defaults

Usage:
  dotconfigs global-configs <plugin>

Description:
  Runs the interactive setup wizard for the specified plugin.
  Creates or updates .env file with plugin configuration.
  These are global defaults applied across all projects.

Available plugins:
EOF
            while IFS= read -r plugin; do
                echo "  - $plugin"
            done < <(discover_plugins "$PLUGINS_DIR")
            cat <<EOF

Examples:
  dotconfigs global-configs claude    Configure Claude Code settings
  dotconfigs global-configs git       Configure git hooks and identity
EOF
            ;;
        project-init)
            cat <<EOF
dotconfigs project-init — Scaffold per-project configuration

Usage:
  dotconfigs project-init [path]

Description:
  Assembles .dotconfigs/project.json from plugin manifests (.project sections).
  Pre-populates include lists, empty exclude lists for customisation.
  Auto-excludes .dotconfigs/ in .git/info/exclude.
  Defaults to current directory if no path given.
  Requires a git repository.

  After creating the config, edit exclude lists, then run: dotconfigs project-deploy <path>

Examples:
  dotconfigs project-init .              Current directory
  dotconfigs project-init ~/myrepo       Specific project
EOF
            ;;
        project-deploy|project)
            cat <<EOF
dotconfigs project-deploy — Deploy per-project configuration

Usage:
  dotconfigs project-deploy [path] [--dry-run] [--force]

Aliases:
  dotconfigs project [path] [options]

Description:
  Reads .dotconfigs/project.json and deploys all configured modules
  (hooks, skills, etc.) as symlinks into the project.
  Respects include/exclude lists per module.
  Defaults to current directory if no path given.
  Requires a git repository with .dotconfigs/project.json.

Options:
  --dry-run       Preview changes without deploying
  --force         Overwrite all conflicts without prompting

Examples:
  dotconfigs project-deploy .                Deploy current project
  dotconfigs project-deploy ~/myrepo --force Deploy, skip conflict prompts
  dotconfigs project-deploy . --dry-run      Preview deployment
EOF
            ;;
        cleanup)
            cat <<EOF
dotconfigs cleanup — Remove stale and broken symlinks

Usage:
  dotconfigs cleanup [--apply] [--dry-run] [--project <path>]

Description:
  Scans deployed target directories and removes:
  - Dotconfigs-owned symlinks not in the current deploy set (stale)
  - Broken/dangling symlinks (regardless of ownership)

  Preserves:
  - Foreign regular files (e.g. user-created hooks)
  - Foreign valid symlinks (e.g. hooks from other tools)

  Default mode is dry-run. Use --apply to actually remove files.

Options:
  --apply          Actually remove stale symlinks (default: dry-run)
  --dry-run        Preview what would be removed (default)
  --project <path> Clean project targets instead of global

Examples:
  dotconfigs cleanup                     Preview stale symlinks
  dotconfigs cleanup --apply             Remove stale symlinks
  dotconfigs cleanup --project .         Preview project cleanup
  dotconfigs cleanup --project . --apply Remove stale project symlinks
EOF
            ;;
        global-deploy|deploy)
            cat <<EOF
dotconfigs global-deploy — Deploy global configuration

Usage:
  dotconfigs global-deploy [group] [options]

Aliases:
  dotconfigs deploy [group] [options]

Description:
  Deploys configuration from global.json to the filesystem via symlinks.
  Without a group name, deploys all groups.
  Also ensures dotconfigs and dots are on PATH.

Options:
  --force          Overwrite all conflicts without prompting
  --dry-run        Preview changes without deploying

Conflicts (files not managed by dotconfigs) prompt for resolution:
overwrite, skip, backup, or diff. Use --force to skip prompts.

Examples:
  dotconfigs deploy                      Deploy all groups
  dotconfigs deploy claude               Deploy claude group only
  dotconfigs deploy git                  Deploy git group only
  dotconfigs deploy --force              Deploy all, overwrite conflicts
  dotconfigs deploy --dry-run            Preview all deployments
EOF
            ;;
        status)
            cat <<EOF
dotconfigs status — Check deployment status

Usage:
  dotconfigs status [plugin]

Description:
  Shows deployment status for plugin configuration files.
  Detects drift (broken symlinks, foreign files, wrong targets).
  Without a plugin name, shows status for all plugins.

States:
  ✓  Deployed      Symlink correctly points to dotconfigs
  △  Drifted       Broken symlink, foreign file, or wrong target
  ✗  Not deployed  File doesn't exist

Examples:
  dotconfigs status           Show status of all plugins
  dotconfigs status claude    Show Claude plugin status only
EOF
            ;;
        list)
            cat <<EOF
dotconfigs list — List available plugins

Usage:
  dotconfigs list

Description:
  Lists all available plugins with deployment status.

Example:
  dotconfigs list
EOF
            ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            echo "" >&2
            echo "Available commands: setup, global-init, deploy, project-init, project, global-configs, status, list, help" >&2
            return 1
            ;;
    esac
}

cmd_help() {
    if [[ $# -eq 0 ]]; then
        show_usage
    else
        show_command_help "$1"
    fi
}

cmd_setup_legacy() {
    echo "Warning: 'dotconfigs setup <plugin>' is deprecated." >&2
    echo "Use: 'dotconfigs global-configs $1' instead." >&2
    return 1
}

cmd_setup() {
    init_colours

    echo ""
    echo "========================================================="
    echo "  dotconfigs - First Time Setup"
    echo "========================================================="
    echo ""

    # Save version marker
    wizard_save_env "$ENV_FILE" "DOTCONFIGS_VERSION" "2.0"

    # Create PATH symlinks (dotconfigs + dots)
    echo "Setting up PATH availability..."
    _create_path_symlink "false" "false"

    echo ""
    echo "Setup complete."
    echo ""
    echo "Next steps:"
    echo "  1. dotconfigs global-init          Scaffold global.json from manifests"
    echo "  2. (optional) Edit .dotconfigs/global.json to customise"
    echo "  3. dotconfigs deploy               Deploy all global config"
    echo "  4. dotconfigs project-init .       Scaffold per-project config"
    echo "  5. dotconfigs project .            Deploy project config"
    echo ""
}

cmd_global_init() {
    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required but not installed." >&2
        exit 1
    fi

    local json
    json=$(assemble_from_manifests "global")

    if ! write_with_overwrite_protection "$GLOBAL_CONFIG" "$json"; then
        return 0
    fi

    echo ""
    echo "Next steps:"
    echo "  1. (optional) Edit .dotconfigs/global.json to customise"
    echo "  2. dotconfigs deploy              Deploy all global config"
}

cmd_global_configs() {
    local plugin=$1

    if [[ -z "$plugin" ]]; then
        echo "Error: Plugin name required" >&2
        echo "Usage: dotconfigs global-configs <plugin>" >&2
        echo "" >&2
        list_available_plugins
        exit 1
    fi

    if ! plugin_exists "$plugin"; then
        echo "Error: Plugin '$plugin' not found" >&2
        list_available_plugins
        exit 1
    fi

    # Load and run plugin wizard
    source "$PLUGINS_DIR/$plugin/setup.sh"
    "plugin_${plugin}_setup" "$@"
}

_create_path_symlink() {
    local dry_run="$1"
    local force_mode="$2"

    # Determine symlink target: prefer ~/.local/bin, fall back to /usr/local/bin
    local target=""
    if [[ -d "$HOME/.local/bin" ]]; then
        target="$HOME/.local/bin/dotconfigs"
    elif [[ -d "/usr/local/bin" ]]; then
        target="/usr/local/bin/dotconfigs"
    else
        # Neither exists, try to create ~/.local/bin
        if mkdir -p "$HOME/.local/bin" 2>/dev/null; then
            target="$HOME/.local/bin/dotconfigs"
        else
            echo "Warning: Cannot create ~/.local/bin and /usr/local/bin not found" >&2
            echo "To make dotconfigs available on PATH, add to your shell profile:" >&2
            echo "  export PATH=\"$SCRIPT_DIR:\$PATH\"" >&2
            return 0
        fi
    fi

    # Dry-run mode
    if [[ "$dry_run" == "true" ]]; then
        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
            echo "CLI availability:"
            echo "  Unchanged: $target → $SCRIPT_DIR/dotconfigs"
            local dots_target="$(dirname "$target")/dots"
            if [[ -L "$dots_target" ]] && [[ "$(readlink "$dots_target")" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "  Unchanged: $dots_target → $SCRIPT_DIR/dotconfigs"
            else
                echo "  Would create: $dots_target → $SCRIPT_DIR/dotconfigs"
            fi
        else
            echo "CLI availability:"
            echo "  Would create: $target → $SCRIPT_DIR/dotconfigs"
            echo "  Would create: $(dirname "$target")/dots → $SCRIPT_DIR/dotconfigs"
        fi
        return 0
    fi

    # Create or verify both symlinks (dotconfigs + dots)
    local symlinks_to_check=("$target" "$(dirname "$target")/dots")
    local symlink_names=("dotconfigs" "dots")

    for i in 0 1; do
        local sym="${symlinks_to_check[$i]}"
        local name="${symlink_names[$i]}"

        if [[ -L "$sym" ]]; then
            local current=$(readlink "$sym")
            if [[ "$current" == "$SCRIPT_DIR/dotconfigs" ]]; then
                echo "$name already on PATH (symlink correct)"
                continue
            else
                # Symlink exists but points elsewhere
                if [[ "$force_mode" != "true" ]]; then
                    echo "Warning: $name symlink exists but points to: $current" >&2
                    wizard_yesno "Overwrite with dotconfigs symlink?" "n" || continue
                fi
            fi
        elif [[ -e "$sym" ]]; then
            echo "Warning: File exists at $sym (not a symlink)" >&2
            continue
        fi

        # Create symlink
        if ln -sf "$SCRIPT_DIR/dotconfigs" "$sym" 2>/dev/null; then
            echo "$name added to PATH: $sym"
        else
            echo "Warning: Failed to create $name symlink at $sym" >&2
        fi
    done
}

cmd_cleanup() {
    local dry_run="true"
    local config_file="$GLOBAL_CONFIG"
    local project_path=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --apply)
                dry_run="false"
                shift
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --project)
                shift
                project_path="${1:-.}"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: dotconfigs cleanup [--apply] [--dry-run] [--project <path>]" >&2
                exit 1
                ;;
            *)
                shift
                ;;
        esac
    done

    # Resolve project config if --project given
    if [[ -n "$project_path" ]]; then
        project_path=$(expand_path "$project_path")
        config_file="$project_path/.dotconfigs/project.json"
    fi

    # Check jq + config exist
    if ! check_jq; then
        return 1
    fi
    if [[ ! -f "$config_file" ]]; then
        echo "Error: config file not found: $config_file" >&2
        exit 1
    fi

    init_colours

    if [[ "$dry_run" == "true" ]]; then
        echo "Cleanup dry-run (use --apply to remove):"
    else
        echo "Cleaning up stale symlinks:"
    fi
    echo ""

    removed=0

    # Parse all modules and run cleanup on each target directory
    local modules_data
    modules_data=$(parse_modules "$config_file")

    if [[ -z "$modules_data" ]]; then
        echo "No modules found."
        return 0
    fi

    while IFS=$'\t' read -r source target method include_csv; do
        local abs_target
        abs_target=$(expand_tilde "$target")

        # If project, resolve relative targets
        if [[ -n "$project_path" && "$abs_target" != /* ]]; then
            abs_target="$project_path/$abs_target"
        fi

        local abs_source
        if [[ "$source" != /* ]]; then
            abs_source="$SCRIPT_DIR/$source"
        else
            abs_source="$source"
        fi

        case "$method" in
            symlink)
                if [[ -d "$abs_source" ]]; then
                    # Directory module: build expected CSV from include list or source dir
                    local deployed_csv=""
                    if [[ "$include_csv" == "__NONE__" ]]; then
                        deployed_csv=""
                    elif [[ -n "$include_csv" ]]; then
                        deployed_csv="$include_csv"
                    else
                        # No include list — all source files are expected
                        for file in "$abs_source"/*; do
                            [[ ! -e "$file" ]] && continue
                            [[ -d "$file" ]] && continue
                            if [[ -n "$deployed_csv" ]]; then
                                deployed_csv="$deployed_csv,$(basename "$file")"
                            else
                                deployed_csv="$(basename "$file")"
                            fi
                        done
                    fi
                    cleanup_stale_in_directory "$abs_target" "$deployed_csv" "$SCRIPT_DIR" "$dry_run"
                else
                    # Single-file symlink: check if target is broken
                    if [[ -L "$abs_target" && ! -e "$abs_target" ]]; then
                        if [[ "$dry_run" == "true" ]]; then
                            echo "  Would remove broken symlink: $abs_target"
                        else
                            rm -f "$abs_target"
                            echo "  ✓ Removed broken symlink: $abs_target"
                        fi
                        removed=$(( removed + 1 ))
                    fi
                fi
                ;;
        esac
    done <<< "$modules_data"

    echo ""
    echo "Cleanup summary:"
    echo "  Removed: $removed"
    if [[ "$dry_run" == "true" && "$removed" -gt 0 ]]; then
        echo ""
        echo "Run 'dotconfigs cleanup --apply' to remove."
    fi
}

cmd_deploy() {
    local group=""
    local dry_run=false
    local force_mode=false

    # Parse arguments: extract group name and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force_mode=true
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
            *)
                # First non-flag argument is the group name
                if [[ -z "$group" ]]; then
                    group="$1"
                fi
                shift
                ;;
        esac
    done

    # Initialize colours for dry-run header
    if [[ "$dry_run" == "true" ]]; then
        init_colours
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo "$(colour_cyan "  DRY RUN - No changes will be made")"
        echo "$(colour_cyan "═══════════════════════════════════════════════════════════")"
        echo ""
    fi

    # Deploy from global.json
    deploy_from_json "$GLOBAL_CONFIG" "$SCRIPT_DIR" "$group" "$dry_run" "$force_mode"

    # Create PATH symlink (after all deploys)
    echo ""
    _create_path_symlink "$dry_run" "$force_mode"
}

cmd_status() {
    local plugin_filter="${1:-}"

    # Initialize colour codes
    init_colours

    # Check if .env exists
    if [[ ! -f "$ENV_FILE" ]]; then
        echo "Error: No configuration found. Run 'dotconfigs setup' then 'dotconfigs global-configs <plugin>' first." >&2
        exit 1
    fi

    # Iterate over all plugins
    while IFS= read -r plugin; do
        # Skip if filter provided and doesn't match
        if [[ -n "$plugin_filter" && "$plugin" != "$plugin_filter" ]]; then
            continue
        fi

        # Source the plugin's deploy.sh if not already sourced
        if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
            source "$PLUGINS_DIR/$plugin/deploy.sh"
        fi

        # Check if plugin_<name>_status function exists
        if declare -f "plugin_${plugin}_status" > /dev/null 2>&1; then
            "plugin_${plugin}_status"
        else
            printf "%b %s\n" "$(colour_red "$plugin")" "not configured"
        fi

        echo ""
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_list() {
    # Initialize colour codes
    init_colours

    # Source .env if it exists
    if [[ -f "$ENV_FILE" ]]; then
        source "$ENV_FILE"
    fi

    echo "Available plugins:"
    echo ""

    while IFS= read -r plugin; do
        local is_installed=false

        # Check if plugin is installed by looking for key env vars
        case "$plugin" in
            claude)
                if [[ -n "${CLAUDE_DEPLOY_TARGET:-}" ]]; then
                    is_installed=true
                fi
                ;;
            git)
                if [[ -n "${GIT_USER_NAME:-}" ]] || [[ -n "${GIT_USER_EMAIL:-}" ]]; then
                    is_installed=true
                fi
                ;;
            *)
                # Generic check: try to load plugin config
                if [[ -f "$PLUGINS_DIR/$plugin/deploy.sh" ]]; then
                    source "$PLUGINS_DIR/$plugin/deploy.sh"
                    if declare -f "_${plugin}_load_config" > /dev/null 2>&1; then
                        if "_${plugin}_load_config" > /dev/null 2>&1; then
                            is_installed=true
                        fi
                    fi
                fi
                ;;
        esac

        # Print with colour
        if [[ "$is_installed" == "true" ]]; then
            printf "  %b %s\n" "$(colour_green "$SYMBOL_OK")" "$plugin deployed"
        else
            printf "  %b %s\n" "$(colour_red "$SYMBOL_MISSING")" "$plugin not deployed"
        fi
    done < <(discover_plugins "$PLUGINS_DIR")
}

cmd_project() {
    local project_path=""
    local dry_run="false"
    local force="false"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run="true"
                shift
                ;;
            --force)
                force="true"
                shift
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: dotconfigs project [path] [--dry-run] [--force]" >&2
                exit 1
                ;;
            *)
                if [[ -z "$project_path" ]]; then
                    project_path="$1"
                    shift
                else
                    echo "Error: Multiple paths specified" >&2
                    exit 1
                fi
                ;;
        esac
    done

    # Default to CWD if no path specified
    if [[ -z "$project_path" ]]; then
        project_path="$PWD"
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    # Check for project.json
    local config_file="$project_path/.dotconfigs/project.json"
    if [[ ! -f "$config_file" ]]; then
        echo "Error: No .dotconfigs/project.json found at $project_path" >&2
        echo "Run: dotconfigs project-init $project_path" >&2
        exit 1
    fi

    # Deploy from JSON
    deploy_from_json "$config_file" "$SCRIPT_DIR" "" "$dry_run" "$force" "$project_path"

    # Auto-exclude .dotconfigs/ in .git/info/exclude (unless dry-run)
    if [[ "$dry_run" != "true" ]]; then
        local exclude_file="$project_path/.git/info/exclude"
        if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
            mkdir -p "$(dirname "$exclude_file")"
            echo ".dotconfigs/" >> "$exclude_file"
            echo ""
            echo "Added .dotconfigs/ to .git/info/exclude"
        fi
    fi
}

cmd_project_init() {
    local project_path=""

    # Parse argument
    if [[ $# -eq 0 ]]; then
        # Check if CWD is the dotconfigs repo itself
        if [[ "$(pwd)" -ef "$SCRIPT_DIR" ]]; then
            echo "Error: Cannot use dotconfigs repo as project target" >&2
            echo "Run from a project directory, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Check if CWD is a git repo
        if ! git -C "$PWD" rev-parse --git-dir >/dev/null 2>&1; then
            echo "Error: Current directory is not a git repository" >&2
            echo "Run from a git repo, or specify a path: dotconfigs project-init /path/to/project" >&2
            exit 1
        fi

        # Use CWD
        project_path="$PWD"
    else
        project_path="$1"
        shift
    fi

    # Resolve to absolute path
    project_path=$(expand_path "$project_path")
    if [[ $? -ne 0 ]]; then
        echo "Error: Invalid path: $project_path" >&2
        exit 1
    fi

    # Validate git repo
    if ! validate_git_repo "$project_path"; then
        echo "Error: Not a git repository: $project_path" >&2
        echo "Initialize with: git init" >&2
        exit 1
    fi

    if ! command -v jq &>/dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq" >&2
        exit 1
    fi

    local config_file="$project_path/.dotconfigs/project.json"
    local json
    json=$(assemble_from_manifests "project")

    if ! write_with_overwrite_protection "$config_file" "$json"; then
        return 0
    fi

    # Auto-exclude .dotconfigs/ in .git/info/exclude
    local exclude_file="$project_path/.git/info/exclude"
    if ! grep -qxF ".dotconfigs/" "$exclude_file" 2>/dev/null; then
        mkdir -p "$(dirname "$exclude_file")"
        echo ".dotconfigs/" >> "$exclude_file"
        echo "Added .dotconfigs/ to .git/info/exclude"
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Edit $config_file"
    echo "  2. Run: dotconfigs project          (from the project directory)"
}

main() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    case "$1" in
        setup)
            # Check if plugin arg provided (legacy mode)
            if [[ $# -gt 1 ]]; then
                cmd_setup_legacy "${@:2}"
            else
                cmd_setup
            fi
            ;;
        global-init)
            cmd_global_init
            ;;
        global-configs)
            cmd_global_configs "${@:2}"
            ;;
        project-init)
            cmd_project_init "${@:2}"
            ;;
        project-deploy|project)
            cmd_project "${@:2}"
            ;;
        cleanup)
            cmd_cleanup "${@:2}"
            ;;
        global-deploy|deploy)
            cmd_deploy "${@:2}"
            ;;
        status)
            cmd_status "${@:2}"
            ;;
        list)
            cmd_list
            ;;
        help)
            cmd_help "${@:2}"
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Error: Unknown command '$1'" >&2
            echo "" >&2
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
